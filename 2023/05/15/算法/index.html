<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/ego/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/ego/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法与数据结构," />










<meta name="description" content="自己练习的算法和常见的数据结构!">
<meta property="og:type" content="article">
<meta property="og:title" content="算法与数据结构">
<meta property="og:url" content="http://example.com/2023/05/15/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Ego">
<meta property="og:description" content="自己练习的算法和常见的数据结构!">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825103851839.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825103918829.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825103941090.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104005822.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104108626.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104135532.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104154003.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104217145.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104233495.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104249292.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104313605.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104338075.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104350993.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104411719.png">
<meta property="og:image" content="http://example.com/%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E8%BF%9B%E5%BA%A6.assets/image-20230724115653903.png">
<meta property="og:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825104448157.png">
<meta property="article:published_time" content="2023-05-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-03T07:25:12.669Z">
<meta property="article:author" content="Ego">
<meta property="article:tag" content="算法与数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/%E7%AE%97%E6%B3%95.assets/image-20230825103851839.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2023/05/15/算法/"/>





  <title>算法与数据结构 | Ego</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ego</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">天道不一定酬所有的勤，但是天道一定酬勤！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/15/%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ego">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法与数据结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-05-15T00:00:00+08:00">
                2023-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  自己练习的算法和常见的数据结构!
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><p>首先一个经典的问题 ：</p>
<ul>
<li>最长公共子序列问题</li>
</ul>
<p>code</p>
<p>这个 暴力的递归的 代码 还是值得 仔细分析 一手的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力 递归 能写 对 的 话 dp  就轻而易举了</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">char</span> []s1 ,<span class="type">char</span>[] s2)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == s1.length || j == s2.length)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> r1,r2,r3;</span><br><span class="line">		r1 = r2  =r3 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(s1[i] == s2[j]) &#123;</span><br><span class="line">			 r1 = process(i + <span class="number">1</span>,j + <span class="number">1</span>,s1,s2) + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			 r2 = process(i + <span class="number">1</span>,j,s1,s2);</span><br><span class="line">			 r3 = process(i,j + <span class="number">1</span>,s1,s2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Math.max(r1,Math.max(r2, r3));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>思维</p>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825103851839.png" alt="image-20230825103851839"></p>
<ul>
<li>一个比较 不一样的 一个 dp 章节  <strong>买卖股票的最佳时机！</strong></li>
</ul>
<blockquote>
<ul>
<li><p>从该题 之后,我就越来越 相信, 所有的 动态规划,都可以写出来, 暴力递归</p>
</li>
<li><p>买卖股票的 最佳时机, 暴力递归 ,已写出来</p>
</li>
<li><p>leetcode 子数组的 最大和 问题 ,暂时 还没有写出来的 这个的暴力版本,( 有点难写)</p>
</li>
<li><p>数组三联 相关的  暴力递归 ,都不太好些.</p>
</li>
<li><p>区间 dp 的 暴力递归 , 有点难写, </p>
</li>
<li><p>但是 只要暴力递归 能够写 出来的话,那么 , 这个 dp  就一定 能通过暴力递归给改出来!</p>
</li>
<li><p>如 果,在 暴力  递归, 改 dp 的过程中遇到一些  棘手的问题, 那么 可以通 过  画出这个 这个 缓存表, 然后分析, </p>
</li>
<li><p>这个 暴力递归,改 dp 的过程, .</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>这个 买卖股票的最佳时机, 在 暴力递归 改写 dp 的过程, 有几点,就很难把握, 但是 ,把这个 缓存表的 图 给画出来, 然后分析依赖关系,那么这个 改造的过程就很简单了!</p>
</li>
<li><p>相关的 分析</p>
</li>
</ul>
<p>![QQ图片20221115164130](C:\Users\I adore you\Desktop\图片\QQ图片20221115164130.jpg)</p>
<ul>
<li>这个 买卖股票最佳时机，通关了！</li>
</ul>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825103918829.png" alt="image-20230825103918829"></p>
<ul>
<li><p>动态规划的 一生！</p>
</li>
<li><p>整数分割 这个题也算是  提供了 一种 新的 暴力递归的思想！ </p>
</li>
<li><p>直接 去思考 这整个的 暴力 枚举的过程， 只要能把 暴力递归写出来，我就能 dp 出来！</p>
</li>
</ul>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>组合求和 这一类的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先掌握 两种去重的方式</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 有两种去重的方式</span></span><br><span class="line"><span class="comment">		 * 下面这是 这是一种</span></span><br><span class="line"><span class="comment">		 * 还有一种是用  used[] 数组来</span></span><br><span class="line"><span class="comment">		 * 去重 </span></span><br><span class="line"><span class="comment">		 * # 去重的关键在于  ** 树枝去重**  还是树层去重</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; choice.length &amp;&amp; rest - choice[i] &gt;= <span class="number">0</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i &gt; index &amp;&amp; choice[i] == choice[i -<span class="number">1</span>])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			path.addLast(choice[i]);</span><br><span class="line">			res += solution5(choice,i + <span class="number">1</span>,ans,path,rest - choice[i]);</span><br><span class="line">			path.removeLast();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"><span class="number">1.</span> i &gt; index &amp;&amp; choice[i] == choice[i - <span class="number">1</span>]</span><br><span class="line"><span class="number">2.</span> i &gt; <span class="number">0</span> &amp;&amp; choice[i] == choice[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    上面两种方式 画图理解一下就明白了</span><br><span class="line">    方式二:  能够使用的范围更广 一些(可能)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个核心的问题 在于 数组中有没有重复的元素这个问题 and 每个元素 能不能重复选的问题 (可能会产生下面四种组合情况)</span></span><br><span class="line">        <span class="number">1.</span> duplicate  and choose more</span><br><span class="line">  		<span class="number">2.</span> not duplicate and choose more</span><br><span class="line">        <span class="number">3.</span> duplicate and  choose once</span><br><span class="line">        <span class="number">4.</span> not duplicate and choose once</span><br><span class="line">        <span class="comment">// 然后再联想一下  左成云 的 ** 钞票面值问题 **</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个问题 在于:  dp 能解决上面的哪些 (回溯能解决的问题)</span></span><br><span class="line">  <span class="comment">//       或者 或者换种说法 上面这些 回溯能解决的问题哪些可以 改成  dp</span></span><br><span class="line">        有重复子过程  就可以 使用一张 缓存表 把重复的子过程存储起来 (关键在于理解  和 找到 重复的 子过程 )</span><br><span class="line">		</span><br><span class="line">        function(rest ,   index           ,.....)</span><br><span class="line">        		  .         .</span><br><span class="line">        		  .         .</span><br><span class="line">    		   变量参数<span class="number">1</span>     可变参数<span class="number">2</span>        常量参数   </span><br><span class="line">        </span><br><span class="line">        如果有 重复的 function(rest , index, ....) 那么直接保存起来</span><br><span class="line">        dp[rest][index];</span><br><span class="line">		再次遇到的 直接 从dp[rest][index] 取值</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 隐式 回溯 和 显式 回溯</span></span><br><span class="line">    --  rest -= choice[i]</span><br><span class="line">        function(rest , i + <span class="number">1</span> ,...)</span><br><span class="line">        rest += choice[i]</span><br><span class="line">    </span><br><span class="line">     --   function(rest - choice[i] ,i + <span class="number">1</span>, ...)</span><br><span class="line"> </span><br><span class="line"> 隐式回溯 具有局限性 (一般 式 数值类型 ,<span class="type">int</span> <span class="title function_">long</span> <span class="params">(或者一些基本数据类型)</span> ) 一旦涉及到 引用数据类型 一定要慎重一下           </span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>这类问题中 basecase 的一些写法  (优化)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span>(rest == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line"><span class="comment">/**  将递归回溯  转换成 二叉树的  版本</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   这 两个 if 的 basecase 的 顺序 是很有   讲究的  </span></span><br><span class="line"><span class="comment"> * 而且 要 按照 这个 顺序的 </span></span><br><span class="line"><span class="comment"> * 为啥 ：</span></span><br><span class="line"><span class="comment"> * 因为 index == nums.length 的  时候 rest 可能 为 0 </span></span><br><span class="line"><span class="comment"> * 那这   就 会出问题  的   最终的 结果 会 少一些 情况 这就是  细节  啊 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 下面 在解释 一下 :</span></span><br><span class="line"><span class="comment"> * 看到这里的 时候 再去   回想一下  leetcode 417 这个 （太平洋  大西洋  的  问题）</span></span><br><span class="line"><span class="comment"> * 下面 这样 写  可以 减少 一下 内存 栈 的 消耗  或者      会不会            更省时间 一些 呢 (省时间 比较  微薄  的 话  其实 就没有 必要 这样写 对吧   )    ??</span></span><br><span class="line"><span class="comment"> * if(rest - nums[index]&gt;= 0)</span></span><br><span class="line"><span class="comment">		ans += process(nums,rest - nums[index],index + 1);</span></span><br><span class="line"><span class="comment">	如果  再 选择  要   当前元素的 时候 加了       判断   那么 </span></span><br><span class="line"><span class="comment">	在 basecase 的 时候 就不用 判断 了 </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	强烈 建议 写成 </span></span><br><span class="line"><span class="comment">	if(rest - nums[index]&gt;= 0)</span></span><br><span class="line"><span class="comment">		ans += process(nums,rest - nums[index],index + 1);</span></span><br><span class="line"><span class="comment">	这种 效率 高些  并且 内存 消耗 更少 一些 </span></span><br><span class="line"><span class="comment">	为啥  ? : 因为          递 归栈  不是 少一些  嘛 这不就 节约   时间   和 空间 了 ??  </span></span><br><span class="line"><span class="comment">	更重要的 是 优化 成  dp 的 时候 也很好 优化 </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	即 可以 直接 这样写   </span></span><br><span class="line"><span class="comment">	if(index == nums.length) &#123;</span></span><br><span class="line"><span class="comment">			return 0;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	而不用 这样写 	</span></span><br><span class="line"><span class="comment">	if(index == nums.length || rest &lt; 0) &#123;</span></span><br><span class="line"><span class="comment">			return 0;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">		<span class="keyword">if</span>(index == nums.length || rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line">    对于 </span><br><span class="line">    <span class="keyword">if</span>( index == choice.length)</span><br><span class="line">        ....</span><br><span class="line">    这个 basecase  什么时候改写什么时候 不该写</span><br><span class="line">    </span><br><span class="line">    ** 可重复 选择的 这种情况 (进入下一 层 递归时  index并没有变化)</span><br><span class="line">        function(rest - choice[index], index)</span><br><span class="line">       </span><br><span class="line">        ① 对于多叉树 这种情况</span><br><span class="line">        因为 存在 (i &lt; length) 这个机制 不会产生数组 越界 异常</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ;i &lt; length ;i++ )</span><br><span class="line">		所以   在  basecase 中 压根 就不用写 下面这个basecase </span><br><span class="line">            <span class="title function_">if</span><span class="params">(index == choice.length)</span></span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       -- 而且 不可重复选择 的这个  basecase</span><br><span class="line">           <span class="title function_">if</span><span class="params">(index == choice.length)</span> </span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		  也不用写</span><br><span class="line">        所以 综上: 多叉树的 这种 i &lt; choice.length 这种机制在 不用 判断 index  越界情况</span><br><span class="line">        </span><br><span class="line">       ②对于二叉树这种情况</span><br><span class="line">            由于 没有 i &lt; choice.length 这种机制</span><br><span class="line">            为了 防止 数组越界异常 需要手动 添加 basecase</span><br><span class="line">            <span class="title function_">if</span><span class="params">(index ==choice.length )</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">   对于 像 </span><br><span class="line">       <span class="keyword">if</span>(rest &lt; <span class="number">0</span>) (这种临界条件的 判断  尽量 在 进入下一层 递归的时候 就给 判断了 这样可以 提升一丢丢的效率 (系统压栈的效率))  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">   就像这样 :</span><br><span class="line">		<span class="keyword">if</span>(rest - choice[index] &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 进入下一层递归 之前 就判断 不满足 直接 当前递归分支 就终止 了 </span></span><br><span class="line">            function(rest - choice[index], index or index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 将这个回溯过程转化成二叉树存在的一些问题（选或者不选）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> 剪枝 问题 (必须排序才能剪枝)</span><br><span class="line"> choice [] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">  需要先对 数组进行排序</span><br><span class="line">  Arrays.sort(choice);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 这个 basecase 是来收集结果的 </span></span><br><span class="line">		 <span class="keyword">if</span>(rest == <span class="number">0</span>) &#123;</span><br><span class="line">			ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 这个 basecase 是来防止 数组 索引越界的</span></span><br><span class="line">		<span class="keyword">if</span>(index == choice.length)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 basecase 是在 排序  的基础上进行 剪枝的</span></span><br><span class="line">		<span class="keyword">if</span>(rest - choice[index] &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 剪枝 需要 牺牲一个 排序的 代价 </span></span><br><span class="line"><span class="comment">// 所以 最终优化后 到底 效率 有没有提升 这不好说  (跟数据量有关系的)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>去重 问题</span><br><span class="line">对于 这种 要 或者不要 而形成的 二叉树来说</span><br><span class="line">有一个很难解决的点就是</span><br><span class="line">很难 解决   ** 树层 去重 **  ** 树枝去重**</span><br><span class="line"><span class="comment">// 对于多叉树 来 说     </span></span><br><span class="line">当前这个题 就是 要  进行  **树层 去重 **</span><br><span class="line"><span class="comment">// 意思就是  同一层 不能重复 而 同一树枝 上是可以重复选的</span></span><br><span class="line"> </span><br><span class="line">--</span><br><span class="line"><span class="comment">//而对于 二叉树 来说  同一层的 概念 就很模糊了  (因为 每一层  就  两个节点) </span></span><br><span class="line">    下面  就是 错误的 代码去重 ( 只想 通过  index 和  choice[index - <span class="number">1</span>] == choice[index]) </span><br><span class="line">    恐怕 不能 达到 和  多叉树 这种 (代码) 去重的效果 </span><br><span class="line">   	<span class="keyword">if</span>(rest == <span class="number">0</span>) &#123;</span><br><span class="line">			ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(index == choice.length)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> index &gt; <span class="number">0</span> &amp;&amp; choice[index - <span class="number">1</span>] == choice[index];</span><br><span class="line">		<span class="comment">// 要当前元素</span></span><br><span class="line">		<span class="keyword">if</span>(rest - choice[index] &gt;= <span class="number">0</span> &amp;&amp; !flag) &#123;</span><br><span class="line">		path.addLast(choice[index]);</span><br><span class="line">		 res =solution6(choice,index + <span class="number">1</span>,ans,path,rest - choice[index]);</span><br><span class="line">		path.removeLast();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不要当前元素 (直接跳到下层 ,rest 什么也不做)</span></span><br><span class="line"><span class="comment">//		if(index &gt; 0 &amp;&amp; choice[index] == choice[index - 1])</span></span><br><span class="line"><span class="comment">//			return 0;</span></span><br><span class="line"><span class="comment">//		boolean flag = (index &gt; 0 &amp;&amp; choice[index] == choice[index - 1]);</span></span><br><span class="line"><span class="comment">//		if(!flag)</span></span><br><span class="line">		res += solution6(choice,index + <span class="number">1</span>,ans,path,rest);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line">    还有一种方法就是 used[] 数组 (success)</span><br><span class="line">    <span class="comment">// 下面就是 完整的 去重 加 剪枝 后的  最终代码</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solution8</span><span class="params">(<span class="type">int</span> [] choice,<span class="type">int</span> index,List&lt;List&lt;Integer&gt;&gt; ans,Deque&lt;Integer&gt; path,<span class="type">int</span> rest,</span></span><br><span class="line"><span class="params">			<span class="type">boolean</span> used[])</span> &#123;</span><br><span class="line">		test8++;</span><br><span class="line">		<span class="keyword">if</span>(rest == <span class="number">0</span>) &#123;</span><br><span class="line">			ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(index == choice.length)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//		// 要当前元素</span></span><br><span class="line"><span class="comment">//		if(rest - choice[index] &gt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//		path.addLast(choice[index]);</span></span><br><span class="line"><span class="comment">//		 res =solution7(choice,index,ans,path,rest - choice[index]);</span></span><br><span class="line"><span class="comment">//		path.removeLast();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(rest - choice[index] &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 要当前元素</span></span><br><span class="line">		<span class="comment">// 去重 条件 一定是 在  **要 当前元素的时候 进行判断**</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> index &gt; <span class="number">0</span> &amp;&amp; choice[index - <span class="number">1</span>] == choice[index] &amp;&amp; used[index - <span class="number">1</span>] == <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">			used[index] = <span class="literal">true</span>;</span><br><span class="line">			path.addLast(choice[index]);</span><br><span class="line">			res =solution8(choice,index,ans,path,rest - choice[index],used);</span><br><span class="line">			path.removeLast();</span><br><span class="line">			used[index] = <span class="literal">false</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">// 不要当前元素 (直接跳到下层 ,rest 什么也不做)</span></span><br><span class="line">		res += solution8(choice,index + <span class="number">1</span>,ans,path,rest,used);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"> --</span><br><span class="line">     至于 元素 是否 可重复选择 </span><br><span class="line">     就是 在 要 当前元素的时候  进入 下层 递归的 时候传入的是 index + <span class="number">1</span>  还是 index </span><br><span class="line">     就这点区别</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>递归(回溯) 写成二叉树 和多叉树 各自的特点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先  单论  递归(回溯) 的效率的 话 多叉树的 要好一些 ( 转换成属性结构的时候  节点 会少一些)</span></span><br><span class="line"><span class="comment">// 节点少 就意味着 递归 系统压栈 就少 一些 (效率就会 高一些)</span></span><br><span class="line"></span><br><span class="line">** 如果 只是个 回溯问题的 话  首先 选择是  多叉树</span><br><span class="line">** 如果 是 dp 的话 二叉树 改 dp 会 容易些    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改 dp 的一些问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">能够改成 dp 的话 还用剪枝 吗 ?</span><br><span class="line">改 dp 的过程中  去重 的这种操作 怎么办? </span><br><span class="line"></span><br><span class="line">但是好像由多叉树 改过来的 dp (去重剪枝 都可以做)?</span><br><span class="line">  如下面这个例子</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dpTwo</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> target)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">len</span>  <span class="operator">=</span> arr.length;</span><br><span class="line">		<span class="type">int</span>  dp [][] = <span class="keyword">new</span> <span class="title class_">int</span> [len + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//		dp[len][0] = 1;</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里 解释 一下为啥 这里 的  index =len 而不是 n -1</span></span><br><span class="line"><span class="comment">		 * 注意 看第三层 for循环 这里  当 index 为 len </span></span><br><span class="line"><span class="comment">		 * 第三层 for  压根 就不会 执行 那为什么 还要  等于 len</span></span><br><span class="line"><span class="comment">		 * 而不是 从 len - 1 开始   </span></span><br><span class="line"><span class="comment">		 * for(int i = index ;i &lt; len &amp;&amp; rest - arr[i] &gt;= 0; i++)</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 其实关键的 点  核心 代码 就是  为了  dp[len][0] =1</span></span><br><span class="line"><span class="comment">		 * 注意 看下面的 代码   当 i = len -1  的 时候 </span></span><br><span class="line"><span class="comment">		 * ways += dp[i + 1][rest - arr[i]];</span></span><br><span class="line"><span class="comment">		 * dp[i+1][rest - arr[i]] 不就是 dp[len][rest - arr[i]] </span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 只要 理解 了 这些 那就  容易</span></span><br><span class="line"><span class="comment">		 * 所以 可以 直接  写 index = len -1</span></span><br><span class="line"><span class="comment">		 * 但是 必须 在  填写 缓存表 之前 把 dp [len][0] = 1; 设置上对吧 </span></span><br><span class="line"><span class="comment">		 * 这不就 全 明白了嘛 </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">index</span> <span class="operator">=</span> len ; index &gt;= <span class="number">0</span>;index -- ) &#123;</span><br><span class="line">			dp[index][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; rest &lt;= target;rest++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ;i &lt; len &amp;&amp; rest - arr[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(i &gt; index &amp;&amp; arr[i] == arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					ways += dp[i + <span class="number">1</span>][rest - arr[i]];</span><br><span class="line">				&#125;</span><br><span class="line">				dp[index][rest] = ways;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][target];</span><br><span class="line">	&#125;</span><br><span class="line"> <span class="comment">// 缺点 三层for 循环</span></span><br><span class="line"><span class="comment">//优点: 剪枝 去重操作 都可以做到</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记忆化搜索好像都可以实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">思考一下这里的问题：</span><br><span class="line">为什么 在 最终简化的 dp 代码 中 去 考虑  **去重**  这个问题</span><br><span class="line">很复杂 因为  dp 是不在意  过程的</span><br><span class="line">而 **剪枝**  或者 ** 去重 ** 都是在 具体的过程中 体现的</span><br><span class="line"> dp 不涉及 过程 这样的 话 想要在 dp 中 **去重** or **剪枝**</span><br><span class="line">  就很麻烦</span><br><span class="line">--</span><br><span class="line"> 但是 记忆化搜索 就不一样了</span><br><span class="line"> 它是 在 搜索的 过程中</span><br><span class="line"> 边 缓存（记忆）  边 搜索</span><br><span class="line"> 就是 在 **过程** 中  缓存 并  搜索</span><br><span class="line">    </span><br><span class="line">总体来说，记忆化搜索 还不错</span><br><span class="line">    这个 什么都能干 </span><br><span class="line">    折中 吧</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 记忆化搜索</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solutionByMemorySearch</span><span class="params">(<span class="type">int</span> choice[],<span class="type">int</span> target)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> choice.length;</span><br><span class="line">		<span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里进行 dp 数组的初始化</span></span><br><span class="line"><span class="comment">		 * 的理由是 dp 数组的值 默认是 0 会  缓存表中的 值产生 影响</span></span><br><span class="line"><span class="comment">		 * 因为 当 dp[index][rest] = 0 的时候  无法确定</span></span><br><span class="line"><span class="comment">		 * 该值  被计算过是 0 ,还是 默认是 0;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= len;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;=  target;j++) &#123;</span><br><span class="line">				dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">boolean</span> used [] = <span class="keyword">new</span> <span class="title class_">boolean</span> [len];</span><br><span class="line">		memorySearch(choice,<span class="number">0</span>,target,dp,used);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][target];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">memorySearch</span><span class="params">(<span class="type">int</span> choice[],<span class="type">int</span> index,<span class="type">int</span> rest,<span class="type">int</span> dp[][],<span class="type">boolean</span> used[])</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[index][rest] != -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> dp[index][rest];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(rest == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> dp[index][rest] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(index == choice.length)</span><br><span class="line">			<span class="keyword">return</span> dp[index][rest] = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 剪枝</span></span><br><span class="line">		<span class="keyword">if</span>(rest - choice[index] &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> dp[index][rest] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//			return 0;</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> index &gt; <span class="number">0</span> &amp;&amp; choice[index] == choice[index - <span class="number">1</span>] &amp;&amp; used[index - <span class="number">1</span>]  == <span class="literal">false</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 要</span></span><br><span class="line">		<span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">		used[index] = <span class="literal">true</span>;</span><br><span class="line">		ans = memorySearch(choice,index + <span class="number">1</span>,rest - choice[index],dp,used);</span><br><span class="line">		used[index] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不要</span></span><br><span class="line">		ans += memorySearch(choice,index + <span class="number">1</span>,rest,dp,used);</span><br><span class="line">		<span class="keyword">return</span> dp[index][rest] = ans;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 剪枝 能做 </span></span><br><span class="line"><span class="comment">// 去重也能做</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面的图片解释了 相应的 递归回溯  二叉树 的过程</p>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825103941090.png" alt="image-20230825103941090"></p>
<p>算法比赛中的最大得分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 二叉树直接 一次过</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> choice[],<span class="type">int</span> index,<span class="type">int</span> rest)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(rest == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(index == choice.length )</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">score1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">score2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(rest &gt;= choice[index] + <span class="number">1</span>)</span><br><span class="line">			score1 = solution(choice,index + <span class="number">1</span>,rest - choice[index] - <span class="number">1</span>) + index;</span><br><span class="line">		</span><br><span class="line">		score2 = solution(choice,index + <span class="number">1</span>,rest);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Math.max(score1, score2);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testsolution</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//		int arr[] = &#123;1,1,0,1,0,0,2,1,0,1,2,0&#125;;</span></span><br><span class="line">		<span class="type">int</span> arr[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">100000</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> solution(arr,<span class="number">1</span>,rest);</span><br><span class="line">		System.out.println(ans);</span><br><span class="line">		System.out.println(dp(arr,rest));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 直接 由上面的 递归 改成 dp</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> choice[],<span class="type">int</span> target)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> choice.length;</span><br><span class="line">		<span class="type">int</span> dp [][] = <span class="keyword">new</span> <span class="title class_">int</span> [len + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 根据basecase 可以看出  这个 dp 表 就不需要初始化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">index</span> <span class="operator">=</span> len - <span class="number">1</span>;index &gt;= <span class="number">0</span>;index--) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>;rest &lt;= target ;rest++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(rest &gt;= choice[index] + <span class="number">1</span>)</span><br><span class="line">					dp[index][rest] = dp[index + <span class="number">1</span>][rest - choice[index] -<span class="number">1</span>] + index;</span><br><span class="line">				dp[index][rest] = Math.max(dp[index][rest], dp[index + <span class="number">1</span>][rest]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][target];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>leetcode 784 字母数字的 大小写全排列</li>
<li>这个问题 真的 很骚！</li>
</ul>
<p>这个题 用<strong>二叉树的回溯</strong>  是可以非常完美的解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的 版本！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> index,List&lt;String&gt; ans,<span class="type">int</span> len,<span class="type">char</span>[] str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == len)</span><br><span class="line">        ans.add(str.toString());</span><br><span class="line">        <span class="comment">// 当前 字符不变 直接跳过</span></span><br><span class="line">        process(index + <span class="number">1</span>,ans,len,str);</span><br><span class="line">        <span class="comment">// 如果当前字符是 字母 ，则 转化进入下一层</span></span><br><span class="line">        <span class="keyword">if</span>(judge(str[index]) == <span class="number">1</span>)&#123;</span><br><span class="line">            str[index] = (<span class="type">char</span>) (str[index] - <span class="number">32</span>);</span><br><span class="line">            process(index + <span class="number">1</span>,ans,len,str);</span><br><span class="line">            str[index] = (<span class="type">char</span>) (str[index] + <span class="number">32</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(judge(str[index]) == <span class="number">2</span>)&#123;</span><br><span class="line">             str[index] = (<span class="type">char</span>) (str[index] + <span class="number">32</span>);</span><br><span class="line">            process(index + <span class="number">1</span>,ans,len,str);</span><br><span class="line">            str[index] = (<span class="type">char</span>) (str[index] - <span class="number">32</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">judge</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c &lt;= <span class="string">&#x27;z&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是 这个 写成 <strong>多叉树 版本的回溯解决不了</strong>  ,就很离谱</p>
<p>画出 这个 递归树, 去分析 就会发现 ,一些 问题在里面!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多叉树的 版本 回溯</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOne</span><span class="params">(<span class="type">int</span> index,List&lt;String&gt; ans,<span class="type">int</span> len,<span class="type">char</span> str[])</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span>(index == len) &#123;</span><br><span class="line"><span class="comment">//    		System.out.println(index);</span></span><br><span class="line">    		ans.add(<span class="keyword">new</span> <span class="title class_">String</span>(str));</span><br><span class="line">    		<span class="keyword">return</span> ;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; len;i++ ) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(judge(str[i]) == <span class="number">1</span>) &#123;</span><br><span class="line">    			 str[i] = (<span class="type">char</span>) (str[i] - <span class="number">32</span>);</span><br><span class="line">    			 processOne(i + <span class="number">1</span>,ans,len,str);</span><br><span class="line">                 str[i] = (<span class="type">char</span>) (str[i] + <span class="number">32</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(judge(str[i]) == <span class="number">2</span>) &#123;</span><br><span class="line">    			 str[i] = (<span class="type">char</span>) (str[i] + <span class="number">32</span>);</span><br><span class="line">    			 processOne(i + <span class="number">1</span>,ans,len,str);</span><br><span class="line">    	         str[i] = (<span class="type">char</span>) (str[i] - <span class="number">32</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">else</span> &#123;</span><br><span class="line">    			processOne(i + <span class="number">1</span>,ans,len,str);</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>























<h3 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h3><p>板子：多多看 ,就会 发现这种真的 很固定!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     二分的 板子 : </span></span><br><span class="line"><span class="comment">     至于 写成 第一种 板子 ,还是 写成 第二种 板子 要根据 题目的条件 进行判断了</span></span><br><span class="line"><span class="comment">     牢记 这两种板子! (因为 有时候 条件 ，就根本 写不成 第一种板子的 判断，所以 第二种 板子 也要 牢记)</span></span><br><span class="line"><span class="comment">     就两种情况:</span></span><br><span class="line"><span class="comment">     ① [l , mid] , [mid + 1, r]</span></span><br><span class="line"><span class="comment">     这种板子 对应的 就是 l = mid + 1, r = mid</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     ②[l , mid - 1] , [mid , r]</span></span><br><span class="line"><span class="comment">     这种板子 对应的 就是 : r = mid - 1, l = mid</span></span><br><span class="line"><span class="comment">     但是 在 求 mid 的时候 需要 ＋ 1 (主要是为了 避免 死循环)</span></span><br><span class="line"><span class="comment">     mid = l + r + 1 &gt;&gt; 1; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	有序 集合!</span></span><br><span class="line"><span class="comment">	找出  &gt;= x 最左边得 值</span></span><br><span class="line"><span class="comment">	或者  &gt; x 得最左边得 值</span></span><br><span class="line"><span class="comment">	&gt; x 最左边得 值 ,等价于 &gt;= x + 1 最左边 的 值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> arr []= &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr[mid] &lt; target)&#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(l);</span><br><span class="line">&#125;、</span><br><span class="line">  </span><br><span class="line"> == 下面这个 就只能 写成第二种 板子 那样， 所以 就写成 第二种 板子 那样就行了， mid 在算的时候 要 + <span class="number">1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tes2</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	有序 集合!</span></span><br><span class="line"><span class="comment">	找出  &lt;= x 最右边得 值</span></span><br><span class="line"><span class="comment">	或者  &lt; x 得最右边得 值</span></span><br><span class="line"><span class="comment">	&lt; x 最左边得 值 ,等价于 &lt;= x -  1 最右边 的 值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> arr []= &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr[mid] &gt; target)&#123;</span><br><span class="line">			r = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			l = mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面 实现 &gt;=  或者  只是 (大于) &gt; 某个数   value 的 最左边的 的数的 下标</span></span><br><span class="line"><span class="comment"> * &gt;= 或者 (大于)  &gt; value 只会让你求 最左边的 数的 下标 </span></span><br><span class="line"><span class="comment"> * 为啥  </span></span><br><span class="line"><span class="comment"> * 因为 &gt;= 或者 (大于)  &gt; 只会让你 求最左侧的 值 下标 </span></span><br><span class="line"><span class="comment"> * 因为 画个 图 在纸上 理解一下就明白 了  </span></span><br><span class="line"><span class="comment"> * &gt;=  和  &gt; 是有点 区别 的 </span></span><br><span class="line"><span class="comment"> * 这个 问题 要想 十分 通透的  理解 必须 得 去 画图 去  慢慢的 理解 </span></span><br><span class="line"><span class="comment"> * 有点  小 绕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于 getLeftIndex 和 getRightIndex 这两个函数</span></span><br><span class="line"><span class="comment"> * 如果 nums 数组中 不存在 指定的 值  target</span></span><br><span class="line"><span class="comment"> * nums [] = &#123;1,2,3,6,8,12,12,12,12,14,15,19,22,44,46&#125;;</span></span><br><span class="line"><span class="comment"> * 如上例子：</span></span><br><span class="line"><span class="comment"> * 查找  target = 13 nums数组中 就没有这个元素 </span></span><br><span class="line"><span class="comment"> * 那么对于 getLeftIndex 来说会 返回  &gt;= 13 的 最左边的元素 也就是  14 (如果有多个14 会返回最左边的 14)的下标</span></span><br><span class="line"><span class="comment"> * 同理对 于 getRightIndex 来说 会返回  &lt;= 13 的最右边的元素的  12(有多个 12 会返回 最右边的 12 )的下标  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLeftIndex</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> value)</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用这个 index 记录着 并更新 这个  满足条件的 最左侧的下标</span></span><br><span class="line"><span class="comment">	 * 可以 省去 </span></span><br><span class="line"><span class="comment">	 * 但是 没必要 </span></span><br><span class="line"><span class="comment">	 * 就算 多用  这一个  int 的变量 又不会 死 干嘛 写的 那么  去 扣 coding 的 简洁</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">	<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">		mid = l + ((r - l )&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里 做个 解释   </span></span><br><span class="line"><span class="comment">		 * int arr []= &#123;5,7,7,8,8,10&#125;;</span></span><br><span class="line"><span class="comment">		 * value  = 7</span></span><br><span class="line"><span class="comment">		 * 对于上面 的   数组 来说 </span></span><br><span class="line"><span class="comment">		 * 条件是 nums[mid] &gt;= value 时候返回的 是   index 是 1</span></span><br><span class="line"><span class="comment">		 * 而条件 是   nums[mid] &gt; value 的时候 返回的 结果 是 index 是 3</span></span><br><span class="line"><span class="comment">		 * 这就不需要 我多解释了 吧 </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span>(nums[mid] &gt;= value) &#123;</span><br><span class="line">			index = mid;</span><br><span class="line">			r = mid -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l  = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面 实现 &lt;= 或者  只是 (小于) &lt; 某个数   value 的 最右 边的 的数的 下标</span></span><br><span class="line"><span class="comment"> * &lt; = 或者 (小于 )  &lt; value 只会让你求 最 右 边的 数的 下标 </span></span><br><span class="line"><span class="comment"> * 为啥  </span></span><br><span class="line"><span class="comment"> * 因为 &lt;=  或者 (小于)  &lt; 只会让你 求 最  右 侧的 值 下标 </span></span><br><span class="line"><span class="comment"> * 因为 画个 图 在纸上 理解一下就明白 了  </span></span><br><span class="line"><span class="comment"> * &lt;=  和  &lt; 是有点 区别 的 </span></span><br><span class="line"><span class="comment"> * 这个 问题 要想 十分 通透的  理解 必须 得 去 画图 去  慢慢的 理解 </span></span><br><span class="line"><span class="comment"> * 有点  小 绕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRightIndex</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> value)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">		mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这里 做个 解释   </span></span><br><span class="line"><span class="comment">	 * int arr []= &#123;5,7,7,8,8,10&#125;;</span></span><br><span class="line"><span class="comment">	 * value  = 7</span></span><br><span class="line"><span class="comment">	 * 对于上面 的   数组 来说 </span></span><br><span class="line"><span class="comment">	 * 条件是 nums[mid] &lt;= value 时候返回的 是   index 是 1</span></span><br><span class="line"><span class="comment">	 * 而条件 是   nums[mid] &lt; value 的时候 返回的 结果 是 index 是 0</span></span><br><span class="line"><span class="comment">	 * 这就不需要 我多解释了 吧 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		<span class="keyword">if</span>(nums[mid] &lt;= value) &#123;</span><br><span class="line">			index = mid;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			r = mid - <span class="number">1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p>leetcode  153  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104005822.png" alt="image-20230825104005822"></p>
<p>这个题 可以 有几种解法：主要是理解  二分的 思想</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"> <span class="comment">// 暴力算法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 排序的代价时    nlg(n)</span></span><br><span class="line">    	<span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">        <span class="comment">// return nums[0];</span></span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 下面的代码时 O(n)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;i &lt; nums.length - <span class="number">1</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i -<span class="number">1</span>] &amp;&amp; nums[i] &lt; nums[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; nums[len -<span class="number">1</span>] ? nums[len - <span class="number">1</span>] : nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分算法  (还是那句话 这里面细节真的是多)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个题的**细节**真的超多的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> nums[])</span> &#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> len -<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">    		<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">if</span>(nums[mid] &gt; nums[r])</span><br><span class="line">    			l = mid + <span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    			r = mid;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> nums[l];</span><br><span class="line"><span class="comment">//    	return nums[l - 1];</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II - 力扣（LeetCode）</a></p>
<ul>
<li>不愧是 困难题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">难度就是不一样哦</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> solution(nums);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> nums[])</span> &#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> len -<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">    		<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">if</span>(nums[mid] &gt; nums[r])</span><br><span class="line">    			l = mid + <span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])</span><br><span class="line">    			r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">             r--;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  while 条件 里面写 l &lt; r  或者 l &lt;= r 都是可以 ac的   </span></span><br><span class="line">    理解一下这个题就明白了</span><br><span class="line">   <span class="comment">// 还是 return nums[l]; 这个返回值 决定的 上面两个 condition  都可以 ac      </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h3 id="贪心问题"><a href="#贪心问题" class="headerlink" title="贪心问题"></a>贪心问题</h3><blockquote>
<ul>
<li><p>很多贪心问题 ,也可以用 暴力 递归 (动态规划来写) 不过  贪心 解法是最优解而已</p>
</li>
<li><p>贪心问题  大量用到<strong>排序</strong>  操作和 <strong>堆</strong>  这种数据结构 </p>
</li>
<li><p>把所有的 贪心的解法 写一下  并且  把所有的 暴力 (递归)方法 和 dp 方法 都去实现一下</p>
</li>
<li><p>暴力递归 和贪心的 一些区别 : </p>
<ul>
<li>暴力递归: 暴力 枚举所有的情况 ,在所有的情况里面选择一个最 符合的 (因为不知道 最优解是怎么产生的 所以 直接  枚举所有的可能)</li>
<li>正确的贪心策略:   我已经知道 怎么<strong>操作</strong> 会产生最优解,  就按 当前 操作  一直 进行 下去</li>
</ul>
<p>所以贪心 和 暴力 递归都 可以 解决 问题 ,只不过  复杂度不一样</p>
<ul>
<li>既然可以使用 暴力递归了, 那么 很大概率  ,也可以  将暴力递归 优化成 动态规划   !</li>
</ul>
</li>
</ul>
</blockquote>
<p>相关的左成云 ：</p>
<p>切木板，与石子合并 的区别</p>
<blockquote>
<ul>
<li><strong>石子合并</strong> 只能 合并相邻的  两堆 石子 ,这就可能导致  无法 使用贪心了 </li>
<li>石子合并 这个  <strong>相邻 这种思想的体现</strong>    观察代码是怎么样来实现  <strong>相邻</strong> 操作的 <strong>前缀数组</strong></li>
<li><strong>切木板</strong>  ,就是石子 合并的一个 变形题 ,可以选择 任意的两堆 石子  进行合并!  </li>
<li>切木板 最优解 就是   <strong>贪心</strong></li>
</ul>
</blockquote>
<p>最恶心的一个点如下:</p>
<blockquote>
<p>在填写 缓存表(dp表)的时候</p>
<p>就是填表的一个顺序问题:</p>
<p>对于石子合并问题,  </p>
<ul>
<li><p>有两种 填表的 方式  都是正确的</p>
</li>
<li><p>最主要的 是  i 和  j   一个顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">填表方式 <span class="number">1.</span></span><br><span class="line"><span class="keyword">for</span>(i  ;  condition;  i vary )&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( j ;  condition ;j vary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">填表方式<span class="number">2.</span></span><br><span class="line">    <span class="keyword">for</span>(j ; condition; j vary)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i ; condition ; i)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">填表方式 <span class="number">1</span> 和 <span class="number">2</span>  的区别就是  i, j <span class="keyword">for</span> 循环的 嵌套!</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p>记住上面这个 惨痛的教训！</p>
<ul>
<li>最有子装载问题 :这个问题的价值 不在于  贪心解法, 而在于这个题  对整个 贪心 和 dp 的 理解还有记忆化搜索</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 多叉树版本</span></span><br><span class="line"><span class="comment">	 * 排个序 </span></span><br><span class="line"><span class="comment">	 * 还可以 进行 剪枝操作!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> choice[],<span class="type">int</span> rest,<span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="comment">//		if(rest == 0)</span></span><br><span class="line"><span class="comment">//			return 1;</span></span><br><span class="line"><span class="comment">//		if(rest &lt; 0) &#123;</span></span><br><span class="line"><span class="comment">//			return 0;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; len;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(rest - choice[i] &gt;= <span class="number">0</span>)</span><br><span class="line">				ans = Math.max(ans, process(i + <span class="number">1</span>,choice,rest - choice[i],len) + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 二叉树版本</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">processTwo</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> choice[],<span class="type">int</span> rest,<span class="type">int</span> len)</span> &#123;</span><br><span class="line">		<span class="comment">//basecase</span></span><br><span class="line">		<span class="keyword">if</span>(index == len)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(rest - choice[index] &gt;= <span class="number">0</span>)</span><br><span class="line">			ans = processTwo(index + <span class="number">1</span>,choice,rest - choice[index],len) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> Math.max(ans, processTwo(index + <span class="number">1</span>,choice,rest,len));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 直接将上面的  二叉树版本的回溯(递归) 改成 dp</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> choice[],<span class="type">int</span> maxValue)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> choice.length;</span><br><span class="line">		<span class="type">int</span> dp [][] = <span class="keyword">new</span> <span class="title class_">int</span> [len + <span class="number">1</span>][maxValue + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> len - <span class="number">1</span>;index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>;rest &lt;= maxValue; rest++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(rest - choice[index] &gt;=<span class="number">0</span> )</span><br><span class="line">					dp[index][rest] = dp[index + <span class="number">1</span>][rest - choice[index]] + <span class="number">1</span>;</span><br><span class="line">				dp[index][rest] = Math.max(dp[index][rest], dp[index + <span class="number">1</span>][rest]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][maxValue];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经典的 四个过程中的 三个 过程</span></span><br><span class="line"></span><br><span class="line">多叉树 回溯</span><br><span class="line">二叉树回溯</span><br><span class="line">记忆化搜索</span><br><span class="line">动态规划    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这两天的一个贪心的收获还是不小的.</p>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104108626.png" alt="image-20230825104108626"></p>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104135532.png" alt="image-20230825104135532"></p>
<p>上面的两个图片是 ,大致的一个手稿吧!</p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/">2136. 全部开花的最早一天 - 力扣（LeetCode）</a></strong></p>
</li>
<li><p>这个 贪心问题 值得一试!  直接 整英文 版的!</p>
</li>
</ul>
<h3 id="一种比较骚的排序"><a href="#一种比较骚的排序" class="headerlink" title="一种比较骚的排序"></a>一种比较骚的排序</h3><p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给出一个数组，nums[] ，</span><br><span class="line">这样排序</span><br><span class="line">    Integer index [] = <span class="keyword">new</span> <span class="title class_">Integer</span> [nums.length];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length; i++)&#123;</span><br><span class="line">        index[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(index, (a,b) -&gt; nums[a] - nums[b] );</span><br><span class="line">思考一下这是 一个 怎么样的 排序方式</span><br><span class="line">    那么排序完成 之后 index 数组 </span><br><span class="line">    中的 索引 就是 nums[] 数组 </span><br><span class="line">    从小 到达排列 之后的 索引 值</span><br><span class="line"><span class="comment">// 其实很简单 , 举个例子 就明白了.	</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h3 id="算法复习进度"><a href="#算法复习进度" class="headerlink" title="算法复习进度"></a>算法复习进度</h3><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p>注意点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这些板子 有一些 非常 致命的问题,</span><br><span class="line">就是 二分查找 找不到 结果的情况,</span><br><span class="line">也就是 集合中, 没有 该要找的值, 这种情况, 就是两个 点 一个 是</span><br><span class="line">0, 一个 nums.length - 1, 这是 找不到 值得情况下 会返回 这两个 其中得一个,</span><br><span class="line">这是因为你得代码 决定的, 但是这种 还有一个问题,就是 ,可能 正确的 ans 也刚好是 0  or nums.length - 1</span><br><span class="line">所以 这种还要 在 返回的 时候, 做一些 特判 才行!</span><br></pre></td></tr></table></figure>





<h5 id="1-二分的板子"><a href="#1-二分的板子" class="headerlink" title="1. 二分的板子"></a>1. 二分的板子</h5><p>注意如果出现 - 1 的</p>
<h5 id="1-2普通的二分的题目-plus-一些前缀和"><a href="#1-2普通的二分的题目-plus-一些前缀和" class="headerlink" title="1.2普通的二分的题目 (+  plus 一些前缀和)"></a>1.2普通的二分的题目 (+  plus 一些前缀和)</h5><h5 id="1-3-二分答案"><a href="#1-3-二分答案" class="headerlink" title="1.3 二分答案"></a>1.3 二分答案</h5><p>这种题目比较固定! </p>
<blockquote>
<p>为什么会有二分答案这个思路?</p>
<p>因为 正常的  根据 **条件求 答案,**不好算,但是 **根据答案求 条件,**比较的好算!</p>
<p><strong>正难则反!</strong></p>
<p>比如 <strong>左Google这道题</strong></p>
<p>① 给出你一个 服务员集合, 求让 n个 服务员们服务 m个人.会发多少时间</p>
<p>②: 给出时间 t, 求在 t 时间内, n 个服务员能服务多少个人,</p>
<p>哪种思路比较的好算?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">套路：</span><br><span class="line">    要求的答案  与  题目的条件     -----》 之间具有单调性（可以稍微的思考可不可以用二分）</span><br><span class="line">     </span><br><span class="line">     二分答案:  一般有三个点 ① 答案()  ② 条件()  ③条件限制 X()</span><br><span class="line">     答案 和 条件 具有单调性 (想一想二分)  (这个单调性是一个比较关键的点!)</span><br><span class="line">         </span><br><span class="line">     check函数 : 是一个 逆推过程,  根据 答案() 推 条件()</span><br><span class="line">     尽量 check函数不要涉及太复杂!</span><br><span class="line"></span><br><span class="line">	check函数可以看作是一个单独 算法题()</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">     这里要特别注意的一个点就是 check() 函数的 返回值() : 一般以 条件() 作为返回值即可</span><br><span class="line">     比如 打家劫舍IV() : 要求的 答案() 是 能力值() , 条件是 小偷偷的不连续的房屋的个数() , 条件的限制是: k</span><br><span class="line">     所以 check() 函数的含义: 在能力值 为 mid 的时候  小偷所能偷盗的不连续的房屋的个数(), 然后再在 二分()和 限制条件k() 进行二分就可以了!</span><br><span class="line">         </span><br><span class="line"><span class="comment">// 单调性：</span></span><br><span class="line">     对于函数 f()来说:</span><br><span class="line">     一点  x0  则 y0 = f(x0) , 任取 一点 x &gt; x0  则有 y = f(x) &gt; y0</span><br><span class="line">     则函数 f() 是单调递增的!</span><br><span class="line">         </span><br><span class="line">         </span><br></pre></td></tr></table></figure>



<ul>
<li><p><input disabled="" type="checkbox"> 
lc2517 (根据答案 去 满足 condition的时候, 还是有点绕的</p>
</li>
<li><p><input disabled="" type="checkbox"> 
2560 <strong>打家劫舍 IV</strong> ( 毫无疑问 ，这道题是一道<strong>十分优秀的题目</strong>)</p>
</li>
<li><p><input disabled="" type="checkbox"> 
左Google面试题</p>
<ul>
<li><input disabled="" type="checkbox"> 暴力做法: 用 <strong>堆</strong>, 来写, 这个暴力方法的思路,比 <strong>二分</strong> ,好难想,但是却很巧妙!</li>
<li><input disabled="" type="checkbox"> 二分答案: <strong>细节方面的处理(也就是题目的理解), 要比这个算法 本身要难!</strong></li>
</ul>
</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>快排, 堆排 , 插入 , 归并,这些一定要会!</p>
<h4 id="dp-1"><a href="#dp-1" class="headerlink" title="dp"></a>dp</h4><blockquote>
<p>宫水三叶的  leetbook  手册</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/detail/designing-data-structures/">设计数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/detail/path-problems-in-dynamic-programming/">动态规划路径问题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p>
<blockquote>
<p>“Storm” : 无后效性的真正含义是，后面的状态只由当前状态和决策决定，而和更早的状态和决策无关。</p>
<p>“知乎李煜东” : 说的 洛谷那道题好像, 也有这种后效性的问题!</p>
<p>这是一直, 你所没有关注的一个点!</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/43361359">(5 封私信 &#x2F; 81 条消息) 动态规划中的无后效性是什么意思？ - 知乎 (zhihu.com)</a></p>
<p>这个 <strong>灵剑</strong> ,有点东西的!</p>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104154003.png" alt="image-20230825104154003"></p>
<blockquote>
<p>这个帖子 还不错的!</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42983849/article/details/108568705">(95条消息) 动态规划——无后效性及如何消除后效性_动态规划 无后效性_大司马学编程的博客-CSDN博客</a></p>
<blockquote>
<p>还得是 <strong>威威哥</strong></p>
<p><strong>买卖股票系列其实全都是这个问题!</strong></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/the-masseuse-lcci/solutions/167193/dong-tai-gui-hua-by-liweiwei1419-8/">面试题 17.16. 按摩师 - 力扣（Leetcode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/38477/bao-li-mei-ju-dong-tai-gui-hua-chai-fen-si-xiang-b/">121. 买卖股票的最佳时机 - 力扣（Leetcode）</a></p>
<blockquote>
<p><strong>贴一下 个人的理解:</strong></p>
<p>其实也没有必要想那么多, 只要记得,  <strong>f() 函数在 做决策的时候 ,你会发现,无法做 决策, 需要一些前置的条件的 考虑能不能通过增加  参数来解决!</strong></p>
<p>这才是最重要的!</p>
</blockquote>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104217145.png" alt="image-20230825104217145"></p>
<ul>
<li>情况一:</li>
</ul>
<p><strong>递归函数 f（） 内出现 for 循环</strong>这个 本质要 弄明白！</p>
<p>主要是跟 当前 <strong>递归层</strong> 的 决策的 数量是有关的, 如可以 可以 穷举的 ,比如 决策 就两个 , 比如 , 背包问题,  do , 或者  dont , 选 或者不选, 变化., 或者不变!</p>
<p>又或者 比如 lc 2266 这道题, 也就是下方图片的模型 :  有 3  or 4 个决策, 不固定, 因为 当前 index 层的数据的不一样,导致 决策不一样, 但是  决策的个数还是, 可以很轻松的 穷举尽的! 但是下面的要注意下:</p>
<blockquote>
<p>一个简单的模型例子: 爬楼梯 , 正常情况下, ①: 两个决策,  一次  1 步, 或者 一次 2 步</p>
<p>再变化一下, 加点 小小的条件 ②: , 比如 在index 层楼梯的时候, 如果 index 是 偶数 ,则可以解锁 额外 buff , 可以一次 走 3 步, 如果是这样的话, 那么奇数层 有 <strong>2 个决策</strong>, 偶数层 有 <strong>3个决策</strong>!,  依旧可以 很轻松的 枚举穷尽!      </p>
<p><strong>也就是  决策约束,  有些 决策 在进行的 时候会有一些 条件的 约束,  决策约束, 这个词用的 非常的不错!</strong></p>
<p>情况③:  在 每一层, 你都可以 选择 爬  <strong>1 ~ k</strong> (输入的值 )步, 那这样的话, 每层的 <strong>决策 就变成  k 个</strong> , 这样的话, 就不好像 上面那样 简单的 枚举决策就行了, 所以</p>
<p>这种情况下, 需要 用  for(int i &#x3D; 决策 1  i &lt;&#x3D; 决策k ;i++) , 需要 对  所有决策 进行一个遍历, 然后 求得 f () 函数  的 结果 就行!   </p>
</blockquote>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104233495.png" alt="image-20230825104233495"></p>
<ul>
<li>情况二:</li>
</ul>
<p>全排列的 题目, 这类题目, 顺序 不固定, 所以 需要 回到 前面取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所以 涉及到全列的时候, 这种 for 是很常见的!,因为 排列 是无序 的!</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len; i++)&#123;</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>















<hr>
<p>李煜东:  递归的前序遍历 和 后续遍历!</p>
<p>记忆化搜索，相对于  dp的优势 在于 很多 basecase 条件 可以 很轻松的就 化解（也就是 所谓的  自动挡）</p>
<p>dp ： dp数组的初始化， 以及basecase的考虑 相较于 记忆化搜索来说， 可能要稍微复杂一些！（手动档）</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
美318dp倒推</p>
</li>
<li><p><input disabled="" type="checkbox"> 
美311美团的最大收益（<strong>这个点， 有个 点，无法确定</strong>）</p>
<ul>
<li><input disabled="" type="checkbox"> lc62 不同路径（<strong>标准的 起点 确定， 终点也确定</strong>） <strong>这里的起点</strong>， <strong>和终点是相对的吧</strong> ， 这确实 是一个 耐人寻味的点！</li>
<li><input disabled="" type="checkbox"> 通过这个不同路径的题目确实， 明白了一些东西！</li>
<li><input disabled="" type="checkbox"> 上面的那两个题一对比 ，这个点，就明白的差不多了！</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
射箭比赛的最大得分</p>
<ul>
<li><input disabled="" type="checkbox"> <ol>
<li>在取得最大得分的时候，最少能用了多少只箭</li>
</ol>
</li>
<li><input disabled="" type="checkbox"> <ol start="2">
<li>取得最大得分的时候， 每个靶子上面分别射了 多少只箭（可能有 多组结果，只给出一种即可！）</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>其实有时候,也并不用想那么复杂!</p>
</blockquote>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104249292.png" alt="image-20230825104249292"></p>
<p>同样的<strong>美团 318（塔子哥的 提瓦特商店</strong>） 以及  <strong>01背包问题</strong> ， 都可以进行上面 两个 方向的扩展！</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
美团318 (提瓦特商店) </p>
<ul>
<li><input disabled="" type="checkbox"> <ol>
<li>能买得最多物品数的时候, 花的最少的钱数</li>
</ol>
</li>
<li><input disabled="" type="checkbox"> <ol start="2">
<li>能买得最多物品数得时候, 买了哪些物品(  可能有多个结果, 给出 一个 结果组即可! )</li>
</ol>
</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
lc 494目标和</p>
</li>
<li><p><input disabled="" type="checkbox"> 
lc377 组合求和4</p>
</li>
<li><p><input disabled="" type="checkbox"> 
洛谷：奖励关（状态压缩的dp，期望dp ，但是 顺推，是错误的！）</p>
<ul>
<li><input disabled="" type="checkbox"> 其实你自己原来的方式，就是 逆推， 这就是你本身习惯的写法！</li>
<li><input disabled="" type="checkbox"> 被 顺推的 的状态转移方程式的 推导过程 给迷惑 好一会时间！</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox"> 
再次 审视 一下acwing 01 背包问题，重新思考一下， dp或者说 递归的 顺推 或者 逆推， 这个点</p>
</li>
</ul>
<blockquote>
<p>洛谷这道题:  希望你能更加的去 理解 这个 <strong>决策 , 约束 等等  这些东西!</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">代码一:</span><br><span class="line">		<span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="type">double</span> temp;</span><br><span class="line">            <span class="comment">// 直接跳过当前 抛出的奖品 （无论，能不能 选）</span></span><br><span class="line">            temp = recursion(index + <span class="number">1</span>,state,init,dp,k,n);</span><br><span class="line">            <span class="comment">//决策 约束！  满足前置条件</span></span><br><span class="line">            <span class="keyword">if</span>((state &amp; init[i][<span class="number">1</span>]) == init[i][<span class="number">1</span>])&#123;</span><br><span class="line">                temp = Math.max(recursion(index + <span class="number">1</span>,state | (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>),init,dp,k,n) + init[i][<span class="number">0</span>],temp);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码二:</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; rewards.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((state &amp; rewards[i][<span class="number">1</span>]) != rewards[i][<span class="number">1</span>])&#123;</span><br><span class="line">                ans += recursion(index - <span class="number">1</span>,state,rewards);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += Math.max(recursion(index - <span class="number">1</span>,state,rewards),recursion(index - <span class="number">1</span>,state | (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>),rewards) + rewards[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans / (rewards.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">代码三:</span><br><span class="line">		<span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="type">double</span> temp;</span><br><span class="line">            <span class="comment">// 直接跳过当前 抛出的奖品 （无论，能不能 选）</span></span><br><span class="line">            temp = recursion(index + <span class="number">1</span>,state,init,dp,k,n);</span><br><span class="line">            <span class="comment">//决策 约束！  满足前置条件</span></span><br><span class="line">            <span class="keyword">if</span>((state &amp; init[i][<span class="number">1</span>]) == init[i][<span class="number">1</span>])&#123;</span><br><span class="line">                temp = Math.max(recursion(index + <span class="number">1</span>,state | (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>),init,dp,k,n) + init[i][<span class="number">0</span>],temp);</span><br><span class="line">            &#125;</span><br><span class="line">           ans = Math.max(ans,temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">    代码二 与 代码一  是 完全等效的! 现在 定义一个 f(i)函数: 表示 **当前** 出现奖品 位 i号的时候,最大收益</span><br><span class="line">    <span class="keyword">for</span> 循环 在做的事 : 求的的 是 当  f(i = <span class="number">1</span>) + f(i = <span class="number">2</span>) + f(i = <span class="number">3</span>) + ......   (每一层递归都是如此)   </span><br><span class="line">    </span><br><span class="line">    而每个 f(i), 又 对应 两种决策, 而且 求的 是这两种 决策 的 <span class="string">&quot;最优决策 &quot;</span>, 当前题目所求的 是 **期望**!</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    而代码三 : 求得是 相当于  max (f(i = <span class="number">1</span>), f(i = <span class="number">2</span>), f(i = <span class="number">3</span>) + .........)    </span><br><span class="line">	同样得 每个 f(i) 都有两个 决策, 而且 求的的是 这两个决策的 <span class="string">&quot;最优决策!&quot;</span> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<ul>
<li><input disabled="" type="checkbox"> lc6244 完美分割方案!</li>
</ul>
<blockquote>
<p>这道题说实话， 跟 <strong>奖励关</strong>， 这题的决策 很相似！</p>
</blockquote>
<p>从 <strong>枚举 + 决策</strong>  来看,这 两个题, 其实是 很类似的! </p>
<p>但是对这道题, 而言, 就是掌握一下, 动态规划的斜率优化!</p>
<blockquote>
<p>把缓存表 给画出来, 然后 去看下其依赖关系, 如果能斜率优化, 应该还是比较 容易能找到的!</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> k,<span class="type">int</span> minLength,String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.length())&#123; <span class="comment">// 这种是 分组， 是必须， 走到 字符串的 末尾 的！ ， 所以这个basecase 才是 最合理的basecase</span></span><br><span class="line">            <span class="keyword">return</span> k == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        if(!judge(s.charAt(index)))&#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 直接 从minLength 开始进行枚举就行了！  //如果当前index 就不是 质数， 就不用走了， 直接返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + minLength;i &lt;= s.length() &amp;&amp; judge(s.charAt(index));i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!judge(s.charAt(i - <span class="number">1</span>)))&#123;</span><br><span class="line">               ans += recursion(i,k - <span class="number">1</span>,minLength,s);</span><br><span class="line">           &#125;</span><br><span class="line">           ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>区别:  从结构上看, 明显 <strong>奖励关</strong> , 这道题会更加的抽象一些,  </p>
<p><strong>奖励关</strong> : 这道题, 相当于 <strong>决策 嵌套</strong>,  外面的 for  循环相当于  <strong>外层决策</strong>, 而 for 循环内部, 有进行了一个 <strong>01决策(还是有限制,前置条件的01 决策)</strong></p>
<p><strong>而完美分割方案</strong> 这道题,就是一个 for 循环 <strong>枚举决策(同样是有些限制的决策!  这里比如这里 对 这个字符串 首尾 字符的限制 )</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分割 方案的 斜率优化的这个过程, 才是 这个题的 一个 非常核心的一个点, 优化起来,非常的丝滑</span><br></pre></td></tr></table></figure>



<p>来模拟一下这个 , 斜率优化的过程!</p>
<p>通过上面的  递归函数, 我们可以 看出 f() 函数的一个依赖关系!</p>
<table>
<thead>
<tr>
<th align="center">………….</th>
<th align="center">k - 1</th>
<th align="center">k</th>
<th align="center">k + 1</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index</td>
<td align="center"></td>
<td align="center">f(index, k)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index + 1</td>
<td align="center">………</td>
<td align="center">f(index + 1,k)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">①</td>
<td align="center">f(index + minLen,k - 1)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">②</td>
<td align="center">f(index + minLen + 1,k - 1)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">f(index + minLen + 2,k - 1)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">f(index + minLen + 3,k - 1)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">f(index + minLen + 4,k - 1)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">f(index + minLen + 5,k - 1)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">f(index + minLen + ……..,k - 1)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + minLength;i &lt;= s.length() &amp;&amp; judge(s.charAt(index));i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(!judge(s.charAt(i - <span class="number">1</span>)))&#123;</span><br><span class="line">           ans += recursion(i,k - <span class="number">1</span>,minLength,s);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<p>你会发现, f(index, k)  依赖是 第 ①行开始的, 而  f(index + 1,k) 的依赖是从第 ②行 开始的, 更重要的是**这里的 限制条件 是 !judge(s.charAt(i - 1)) ** ,  就是 <strong>子字符串的结尾</strong>,  而对于 无论是 从 index, 开头, 还是 从 index + 1 开头的子串,  都从第②行开始,都是相同的! </p>
<blockquote>
<p>so :   这他妈 理解的是有偏差的!</p>
</blockquote>
<p><strong>还是那句话, 一定要 弄清楚  f() 函数的定义</strong> : </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f(index, k) 表示的是:  把从index开头字符串 分成 k 组 的分割方案数目!</span><br><span class="line">但是 这道题的条件限制的非常 e 心 ,比如 index 开头的限制, 必须以 **质数开头**!</span><br><span class="line"></span><br><span class="line">如果 当前 index 是非质数, f(index,k) = 0, 那么 f(index + 1, k) 这种斜率优化, 就没有任何的意义!</span><br><span class="line"></span><br><span class="line">f(index + minLen, k - 1) : index + minLen 是当前的开头 确实 f(index,k) 的一个结尾!</span><br></pre></td></tr></table></figure>



<blockquote>
<p>这道题, 确实 有点搞!</p>
<p>看下 <strong>灵神的题解</strong>, 他顺便给出了, 相似的题目!</p>
</blockquote>
<ul>
<li><p><input disabled="" type="checkbox"> 
lc 1977划分数字的方案数</p>
</li>
<li><p><input disabled="" type="checkbox"> 
lc2463最小移动总距离</p>
</li>
<li><p>左程云， <strong>美团无限大的宝藏</strong>  ， 离散 加 图的遍历！</p>
</li>
<li><p>字节：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mt4y1M7Pd/?spm_id_from=333.999.0.0&vd_source=179da737184de5a8f84e4f6c2ee5c350">https://www.bilibili.com/video/BV1mt4y1M7Pd/?spm_id_from=333.999.0.0&amp;vd_source=179da737184de5a8f84e4f6c2ee5c350</a></p>
<ul>
<li>所有的程序员， 都应该看看的题， 上面的题，涉及到bitMap</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox"> 
数组 来模拟二叉树</p>
</li>
<li><p><input disabled="" type="checkbox"> 
tank 博客上面的那道二叉树的题目</p>
</li>
<li><p><input disabled="" type="checkbox"> 
<strong>回溯系列</strong></p>
<ul>
<li><p><input disabled="" type="checkbox"> 
先去做左程云的回溯系列(希望能快速的 秒一下 这个系列!)</p>
</li>
<li><p><input disabled="" type="checkbox"> </p>
<pre><code class="sh">lc2257统计网格图中没有被保卫的格子数
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- [ ] 子数组 , 子序列的 问题, 一个要求连续, 一个 并未要求连续</span><br><span class="line">  - [ ] 而子数组问题,  因为子数组是要求的连续的 ,一旦涉及连续的 **求和** 需要的时候, 那么前缀和 这个东西,就可以很好的 排上用场!</span><br><span class="line">  - [ ] 看一下 **数组三联中md 中一些** 经典的 问题:</span><br><span class="line">  - [ ] 给出一个 数组, 请把 数组 分成 k 组?  </span><br><span class="line">    - [ ] 如果 连续的话,  经典的 dp问题, 如果在涉及到 子数组的求和,那就更经典了!</span><br><span class="line">      - [ ] 有很多这样的题, 在dp 系列里面!</span><br><span class="line">    - [ ] 并未要求连续的话, 这好像,有点抽象! 连续 反而更好做一些!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- [ ] 子数组,子串, 和 子序列 这类的 题目</span><br><span class="line"></span><br><span class="line">  - [ ] lc131 切割回文子串</span><br><span class="line"></span><br><span class="line">  - [x] lc 647回文子串  : 这个题, **能印出来很多的东西在里面!**</span><br><span class="line"></span><br><span class="line">    - [ ] 如果 用 **递归** 的话, 你会发现,没法一步到位 比如 **f(i ,j )** 表示  s[i, j] 是不是 回文串, 你会发现这个函数的作用只能判断 **一堆 i, j**</span><br><span class="line">    - [ ] 但是 如果 你把这个递归转换成  **dp** 就不一样, dp 的循环,会 **枚举 所有的 情况**</span><br><span class="line">    - [ ] 你会发现这道题,没法 一步到位,直接求出最终的 结果,但是 我们 求出 dp 这个缓存表之后 , **根据dp[i][j**无论是求   **回文子串的个数**, 还是 **最长回文子串** 这都是很简单的事情</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    </span><br><span class="line">    // 这也验证了 , 我的结论:</span><br><span class="line">       -  如果是 子数组 或者子串, f(i, j) 表示的是 以 i 靠头, 以 j 结尾 (这个 是严格的 要求!)</span><br><span class="line">        而且 一般 这种子数组 或者 子串的问题, 往往 递归函数 f(i ,j) (函数的参数, 根据题目的 要求去写) 是无法一步到位的,</span><br><span class="line">        也就是说,无法一步 就直接求出 最终的结果, 但是 往往 改成 dp 的时候,  就解决了这个问题.</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      -  而子序列 f(i ,j ) 表示的 是  [i , j ]内 怎么怎么样</span><br><span class="line">    	这种子序列的问题, 往往 是能一步到位的, 就是 f() 函数,直接就能求出最后的结果!</span><br><span class="line">         比如 这里的 ** 最长回文子序列 ** </span><br><span class="line">         dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]</span><br><span class="line">            </span><br><span class="line">       - 复习的 的时候, 把  **另类的动态规划里面的题目复习一下** , 会更加的深刻!</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p><input disabled="" type="checkbox"> 
lc5 最长回文子串</p>
</li>
<li><p><input disabled="" type="checkbox"> 
lc516 最长回文子序列</p>
</li>
<li><p><input disabled="" type="checkbox"> 
另类包中 : 各种的 子数组和 子序列的题</p>
<ul>
<li><input disabled="" type="checkbox"> 子序列 : f(i , ..) 表示的 是 <strong>i ~ len 之间</strong>  怎么怎么样</li>
<li><input disabled="" type="checkbox"> 子数组 或者 子串,  f( i , …  表示的是 ) 以 <strong>i开头</strong>  怎么怎么样</li>
<li><input disabled="" type="checkbox"> 目前大致的 经验性的理解是这样的!</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox"> 
lc300 最长增 序列</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码一:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> [] nums)</span>&#123;</span><br><span class="line">        <span class="comment">// nums[index] 本身 长度 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> index + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &lt; nums[j])&#123;</span><br><span class="line">                ans = Math.max(ans,recursion(j + <span class="number">1</span>,nums) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">这个虽然是 子序列的题, 但是这个题 ,没办法 一步 求出结果!</span><br><span class="line">而且  此时  f(i) : 表示的 是 以 i 开头的 最长 增 子序列 的长度  ** ① **</span><br><span class="line">  而不是 f(i) : 从 i ~ len - <span class="number">1</span> 范围 最长 增 子序列的长度      ** ② **</span><br><span class="line"></span><br><span class="line"> 但是我可以强行把  f(i) 定义成  ** ② **, </span><br><span class="line">那么 f() 函数 就变成:</span><br><span class="line"><span class="comment">// 代码二:</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> [] nums)</span>&#123;</span><br><span class="line">        <span class="comment">// nums[index] 本身 长度 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> index + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &lt; nums[j])&#123;</span><br><span class="line">                ans = Math.max(ans,recursion(j,nums) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = Math.max(ans,recursion(j,nums));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">代码二 的变化, 仅仅是 多加个  <span class="keyword">else</span> 的 递归 循环,</span><br><span class="line">但是 这个代码是不 正确的!</span><br><span class="line">    eg: [<span class="number">4</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>]   答案: <span class="number">3</span>   输出: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 还是 具体的 题目具体分析!</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>通过下面这一系列的组合,明白了</p>
<ol>
<li><strong>递归的时间复杂度 计算</strong></li>
<li><strong>递归  , 记忆化搜索,  dp 之间的时间复杂度的 联系!</strong></li>
<li><strong>以及 利用 path数组,进行路径回溯的能力</strong></li>
</ol>
</blockquote>
<p>还有一个比较核心的点:  <strong>就是要深刻的理解 多定义的  f() 函数的定义, 一定要深刻的理解</strong></p>
<ul>
<li><input disabled="" type="checkbox"> lc674 最长  <strong>连续</strong> 增序列</li>
<li><input disabled="" type="checkbox"> lc 300最长 上升子序列 </li>
<li><input disabled="" type="checkbox"> lc 673 最长递增子序列的个数 (lc 300 的基础上, 多求解了 <strong>个数</strong>)</li>
<li><input disabled="" type="checkbox"> lc 368最大整除子集( lc300 的 基础上,求解 路径 )<ul>
<li><input disabled="" type="checkbox"> 有空 可以去尝试一下, 这个题 的 递归(  回溯 )写法,  我还是 感觉 是 可以写出来的!</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> lc 射箭比赛的最大得分(又是 这个题!) 这个题,真的 tm 太猛了</li>
</ul>
</li>
</ul>
<p>首先再对时间复杂度进行一个分析!</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">N^N &gt; N! &gt; 2^N &gt; N^2 </span><br><span class="line">这是  递归 or dp中常用的 一些时间 复杂度</span><br><span class="line">- 其中 N^N 是 出现在  **全排列** 或者  N皇后中 ,没有优化的版本,是这个时间复杂度</span><br><span class="line">但是在 **递归** 的时候,如果进行一些剪枝操作的话, 时间复杂度可能 会降到 N!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 01背包, 组合求和,以及 决策就 2种这种递归 的时间复杂度是  2 ^ N </span><br><span class="line">比如 01 背包问题, 物品的数量 为 N , 容量为 V, 时间复杂度就是 固定的 2 ^ N ,跟容量V 没有关系</span><br><span class="line">因为 N 是递归的深度, 而 2 是递归中 决策的个数!</span><br><span class="line">所以  01背包 或者 类似01 背包这种的 递归的时间复杂度是 2 ^ N</span><br><span class="line">code :</span><br><span class="line"> int f(index, rest)&#123;</span><br><span class="line"> 	f(index + 1, rest);</span><br><span class="line"> 	<span class="keyword">if</span>(rest - nums[index] &gt;= 0)&#123;</span><br><span class="line"> 	f(index + 1, rest - nums[index])</span><br><span class="line"> 	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">很明显: 递归的深度 跟 rest 没有关系, 只与 index 有关系! index ∈[0,N)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 那记忆化搜索的时间复杂度,是怎么回事呢?</span><br><span class="line">记忆化搜索,就是在 上述code 的基础上,加一个缓存表对吧!</span><br><span class="line"> int f(index, rest)&#123;</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">if</span>(dp[index][rest] 已经计算过)&#123;</span><br><span class="line"> 		直接返回!</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	f(index + 1, rest);</span><br><span class="line"> 	<span class="keyword">if</span>(rest - nums[index] &gt;= 0)&#123;</span><br><span class="line"> 	f(index + 1, rest - nums[index])</span><br><span class="line"> 	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">所以对加了 缓存表dp 的记忆忧搜索来说, 其实 递归 只进行了 缓存表 大小的 递归次数,也就是 N * V </span><br><span class="line">因为 一旦dp[index][rest] **被计算过,直接返回** ,所以此时, 记忆化搜索的时间复杂度就是相当于,填一张 dp缓存表的时间复杂度,也就是 O(N * V)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- dp就不用说了吧 ,两个 <span class="keyword">for</span> 循环嘛</span><br><span class="line">时间复杂度就是 O(N * V)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 所以 你会发现一个点 :</span><br><span class="line">	- 递归的时间复杂度 和 V 没有关系, 虽然没有 但是 它的时间复杂度是指数 级别的,增长的非常恐怖😱!</span><br><span class="line">	所以 当 N 取 很小的时候,递归才 能过! 但是 一般来说  N常见的取值 是  [10^3, 10^5] 这种的话, 递归就不要 想能AC 了,根本过不了!</span><br><span class="line">	但是 想 **射箭比赛的最大得分这道题** , N 是 12, 所以 递归能过,而且非常的快!</span><br><span class="line">	</span><br><span class="line">	2 ^ 26 ≈  10 ^ 18 , 所以 如果 N &lt; 26 递归还是有可能过的!</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	- 记忆化搜索和 dp 的时间复杂度 和 V 有关系</span><br><span class="line">	</span><br><span class="line">	局限于 N 取值 通常不会 很小, 所以 dp 和记忆化 搜索, 还用很好用的!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<blockquote>
<p>还有两个切割问题:</p>
<ul>
<li><input disabled="" type="checkbox"> 数字切割游戏</li>
<li><input disabled="" type="checkbox"> lc2698求一个数的惩罚数</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        long find(String s,long sum,int idx)&#123;</span><br><span class="line">        if(idx==s.length())&#123;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">        long ans=0;</span><br><span class="line">        for(int i=idx+1;i&lt;=s.length();i++)&#123;</span><br><span class="line">            ans+=find(s,sum+Long.parseLong(s.substring(idx,i)),i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">- 类似的这种切割 的 代码,其实时间复杂度 是 2 ^ N</span><br><span class="line">我有点确定不了了, 可以直接去数, 这个棵树的 结点数,就是其时间复杂度</span><br><span class="line">递归的深度,应该是 N 吧, 但是然后怎么分析呢?</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><input disabled="" type="checkbox"> <strong>lc1186一次删除得到最大子数组和</strong></li>
</ul>
<blockquote>
<p>难点是这个状态转移!</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"> l<strong>c6912构造最长非递减子数组</strong></li>
</ul>
<blockquote>
<p>这个题真的经典!</p>
<p>拓展思维, 锻炼心态!</p>
</blockquote>
<p><strong>状态机dp</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/solutions/1268315/dian-xing-de-zhuang-tai-ji-dpwen-ti-by-y-q6mq/">1186. 删除一次得到子数组最大和 - 力扣（Leetcode）</a></p>
</blockquote>
<p><strong>灵神的题解, 不仅仅是该道题!  动态规划的决策问题!</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/solutions/2321829/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-hzz6/">1186. 删除一次得到子数组最大和 - 力扣（Leetcode）</a></p>
</blockquote>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104313605.png" alt="image-20230825104313605"></p>
<p>这道题, 跟<strong>买卖股票的最佳时机系列</strong>确实 有点异曲同工之处!</p>
<p>尤其是 这个  <strong>state</strong>  ,  只不过在不同的 state 下, <strong>决策 有点区别!</strong></p>
<ul>
<li><input disabled="" type="checkbox"> <strong>lc1723最小工作时间</strong></li>
</ul>
<blockquote>
<p>这题有点太扯淡,  超出我 的能力范围了!</p>
</blockquote>
<p>直接从这里面. 去 窥探切割的点!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">将集合 s 分成 k 个子集合的分法数量是一个组合数学问题，可以使用递归或动态规划来解决。</span><br><span class="line"></span><br><span class="line">一种常见的方法是使用动态规划。我们可以定义一个二维数组 dp，其中 dp[i][j] 表示将前 i 个元素分成 j 个子集合的分法数量。递推关系如下：</span><br><span class="line"></span><br><span class="line">当 i &lt; j 时，无法将前 i 个元素分成 j 个子集合，所以 dp[i][j] = <span class="number">0</span>。</span><br><span class="line">当 i = j 时，前 i 个元素正好可以分成 j 个子集合，所以 dp[i][j] = <span class="number">1</span>。</span><br><span class="line">当 i &gt; j 时，对于第 i 个元素，我们可以选择将其放入某个已有的子集合中，或者将其作为一个新的子集合。因此，dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j]，其中 dp[i-<span class="number">1</span>][j-<span class="number">1</span>] 表示将前 i-<span class="number">1</span> 个元素分成 j-<span class="number">1</span> 个子集合的分法数量，dp[i-<span class="number">1</span>][j] 表示将前 i-<span class="number">1</span> 个元素分成 j 个子集合的分法数量。</span><br><span class="line"></span><br><span class="line">最终的结果是 dp[n][k]，其中 n 是集合 s 的大小。</span><br><span class="line">    </span><br><span class="line">--</span><br><span class="line">    按照你的习惯: 估计你的 状态方程转移方程式: dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    dp[i + <span class="number">1</span>][j] : 表示的含义是: 将 当前元素 i 放入 已有的 某个集合的操作, 把 i + <span class="number">1</span> ~ len 分成 j 份 的 方案树!</span><br><span class="line">        - 同时 问题, 如果题目稍微 加点难度的话, 就会涉及到, 元素 i 放到已有的某个 集合, 那放入的是哪个集合?</span><br><span class="line">        - 这是一个 非常 值得探讨的问题!</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    dp[i + <span class="number">1</span>][j - <span class="number">1</span>] : 表示的含义: 将当 元素 i 作为一个 新的分组, 此时 分组个数 j 要 - <span class="number">1</span> , 表示 把 i + <span class="number">1</span> ~ len 分成 j - <span class="number">1</span> 份</span><br><span class="line">    的方案数!   </span><br><span class="line">  </span><br><span class="line"><span class="comment">//  GPT 生成的代码!  这里面涉及到一些地方的剪枝的操作!       </span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countPartition</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.min(i, k); j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>官方答案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTimeRequired</span><span class="params">(<span class="type">int</span>[] jobs, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> jobs.length;</span><br><span class="line">    <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.numberOfTrailingZeros(i), y = i - (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">        sum[i] = sum[y] + jobs[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[k][<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = sum[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> j; x != <span class="number">0</span>; x = (x - <span class="number">1</span>) &amp; j) &#123;</span><br><span class="line">                minn = Math.min(minn, Math.max(dp[i - <span class="number">1</span>][j - x], sum[x]));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = minn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k - <span class="number">1</span>][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>DFS 的一个做法!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] jobs;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTimeRequired</span><span class="params">(<span class="type">int</span>[] _jobs, <span class="type">int</span> _k)</span> &#123;</span><br><span class="line">        jobs = _jobs;</span><br><span class="line">        n = jobs.length;</span><br><span class="line">        k = _k;</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        dfs(<span class="number">0</span>, sum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * u   : 当前处理到那个 job</span></span><br><span class="line"><span class="comment">     * sum : 工人的分配情况          例如：sum[0] = x 代表 0 号工人工作量为 x</span></span><br><span class="line"><span class="comment">     * max : 当前的「最大工作时间」</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span>[] sum, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">            ans = max;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            sum[i] += jobs[u];</span><br><span class="line">            dfs(u + <span class="number">1</span>, sum, Math.max(sum[i], max));</span><br><span class="line">            sum[i] -= jobs[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20230628181827090](C:\Users\I adore you\AppData\Roaming\Typora\typora-user-images\image-20230628181827090.png)</p>
<p><strong>上面的 这个 DFS 的做法,其实 就是在  遍历模拟 找出  把 当前  i 元素 放入 哪个 集合中, 能够使  答案变得更加 优!</strong></p>
<ul>
<li><p><input disabled="" type="checkbox"> 
前缀和 +  哈希 （常见的预处理手段！）</p>
<ul>
<li><input disabled="" type="checkbox"> 入门题:  <strong>转化的 思路 要明确！</strong><ul>
<li><input disabled="" type="checkbox"> 两数之和的思考</li>
<li><input disabled="" type="checkbox"> lc2395这个题,思考完之后,再去 整 <strong>和为k 的子数组</strong> ,  这样会不会有一点新的理解呢!</li>
<li><input disabled="" type="checkbox"> lc525 01个数相等的最长的子数组的长度</li>
<li><input disabled="" type="checkbox"> <strong>求长度， 求个数， 两种类型！</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox"> 
lc128  最长的连续序列,(大厂经典手撕面试题!)(哈希表类型的题目!)</p>
</li>
</ul>
<h4 id="看下高手的总结"><a href="#看下高手的总结" class="headerlink" title="看下高手的总结"></a>看下高手的总结</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/jq9Zke/">论如何 4 个月高效刷满 500 题并形成长期记忆 - 力扣（LeetCode）</a></p>
<ul>
<li>lc 的插件</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/XYShaoKang/refined-leetcode">XYShaoKang&#x2F;refined-leetcode: 网页版力扣扩展,提高 LeetCode-cn 刷题体验 (github.com)</a></p>
<h4 id="股票系列"><a href="#股票系列" class="headerlink" title="股票系列"></a>股票系列</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FL411g74Z/?spm_id_from=333.999.0.0&vd_source=179da737184de5a8f84e4f6c2ee5c350">化身股神用算法分析股票问题，一套打穿股票系列_最长+1递增子数组_子数组的最大累加和_鹅厂文化衫问题_哔哩哔哩_bilibili</a></p>
<ul>
<li>主要去明白这个动态规划参数的，一个考虑的准则！</li>
<li>恒生笔试那道 股票题 ?</li>
</ul>
<h4 id="差分系列"><a href="#差分系列" class="headerlink" title="差分系列"></a>差分系列</h4><p>把这一块的题  给复习一下， 尤其是  <strong>离散化差分</strong></p>
<blockquote>
<p>把下面三兄弟给做了,  <strong>离散化差分</strong> , 有一个差不多的认识了!</p>
</blockquote>
<ul>
<li>美团流星的那道题 (毫无疑问这是道非常好题)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间 复杂度 O(N* lgN)  空间   O(N)  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(sc.nextLine());</span><br><span class="line">        <span class="type">int</span>[] st = Arrays.stream(sc.nextLine().split(<span class="string">&quot; &quot;</span>)).mapToInt(Integer::<span class="keyword">new</span>).toArray();</span><br><span class="line">        <span class="type">int</span>[] et = Arrays.stream(sc.nextLine().split(<span class="string">&quot; &quot;</span>)).mapToInt(Integer::<span class="keyword">new</span>).toArray();</span><br><span class="line"></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; diff = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            diff.put(st[i], diff.getOrDefault(st[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            diff.put(et[i] + <span class="number">1</span>, diff.getOrDefault(et[i] + <span class="number">1</span>, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : diff.entrySet()) &#123;</span><br><span class="line">            sum += entry.getValue();</span><br><span class="line">            ans = Math.max(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在数组中操作会比较的好操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         下面这种方式非常的巧妙</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         因为map 中存储的是 离散化的 st  和et  **点**</span></span><br><span class="line"><span class="comment">         也就是说 st 和 et  在map 中 是不连续的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            这里直接枚举 entry 中的每个点， 作为 流星的 开始起点时间</span></span><br><span class="line"><span class="comment">            如果 此时 达到 max， 则 nextKey - curKey 就是 这个流星区间内的所有满足条件的时间点：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            ** 核心是枚举起始时间点 **</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt;[] entries = diff.entrySet().toArray(<span class="keyword">new</span> <span class="title class_">Map</span>.Entry[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; entries.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            sum += entries[i].getValue();</span><br><span class="line">            <span class="keyword">if</span> (sum == ans) &#123;</span><br><span class="line">                count += entries[i + <span class="number">1</span>].getKey() - entries[i].getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans  + <span class="string">&quot; &quot;</span> + count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>堆的做法:</p>
<p>堆的做法, 要远比  **离散  + 差分 **  要难:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    堆的一个做法, 最大重合的区间的个数, 以及最大重合区间的 点数 ( 有多个最大重合区间  )</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(sc.nextLine());</span><br><span class="line">       <span class="type">int</span>[] st = Arrays.stream(sc.nextLine().split(<span class="string">&quot; &quot;</span>)).mapToInt(Integer::<span class="keyword">new</span>).toArray();</span><br><span class="line">       <span class="type">int</span>[] et = Arrays.stream(sc.nextLine().split(<span class="string">&quot; &quot;</span>)).mapToInt(Integer::<span class="keyword">new</span>).toArray();</span><br><span class="line">       <span class="type">int</span> [][]times = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">           times[i][<span class="number">0</span>] = st[i];</span><br><span class="line">           times[i][<span class="number">1</span>] = et[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// sort</span></span><br><span class="line"></span><br><span class="line">       Arrays.sort(times,(a,b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">       PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; queue.peek() &lt; times[i][<span class="number">0</span>])&#123;  <span class="comment">// 重合的 点 时刻, 也是 合法的区间</span></span><br><span class="line">               queue.remove();</span><br><span class="line">           &#125;</span><br><span class="line">           queue.add(times[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">           <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queue.size();</span><br><span class="line">           <span class="keyword">if</span>(ans == temp)&#123;</span><br><span class="line">               count += queue.peek() - times[i][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ans &lt; temp)&#123;</span><br><span class="line">               ans = temp;</span><br><span class="line">               count = queue.peek() - times[i][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(ans + <span class="string">&quot; &quot;</span> + count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>









<ul>
<li><p>左程云的 线段的最大重合程度</p>
</li>
<li><p>花期的最大花期（离线查询）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个题 ** 花期得题, 绝对 是理解  这里 离散化 差分得最好例题! **</span><br><span class="line"></span><br><span class="line"> - 等后面有精力得时候,可以看看 **堆** 的做法</span><br></pre></td></tr></table></figure>























<p> <a href="E:\algorithm\力扣\力扣牛哥\leetcode-posts\topics\图论算法从入门到放下.md">力扣牛哥</a></p>
<h4 id="树和图"><a href="#树和图" class="headerlink" title="树和图"></a>树和图</h4><blockquote>
<p>图的话, 就是那几个 图 的 经典算法,给整明白, 就可以了!</p>
<p>因为 图 出难题,那是真的 难题, 把图的经典的算法给整明白, </p>
<p>主要是 树 (尤其是二叉树, 更加的重要!)</p>
</blockquote>
<blockquote>
<p>不用node 节点的方式,  来遍历   树  和图, </p>
<p>就单纯的用 数组, 来遍历树 和图, 这是可以实现的!</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"> lc 2466 树上得分最大  (这个题 有很强的一个思考的空间)<ul>
<li><input disabled="" type="checkbox"> 这个题是真的服气</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">这道题 还学会的一个点就是:</span><br><span class="line"><span class="number">1.</span> 图的遍历的了解</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">bobToNode</span><span class="params">(<span class="type">boolean</span> []used,HashMap&lt;Integer,List&lt;Integer&gt;&gt; graph,<span class="type">int</span> []map,<span class="type">int</span> node,<span class="type">int</span> curTime)</span>&#123;</span><br><span class="line">  			.........</span><br><span class="line">        used[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> no : graph.get(node))&#123; <span class="comment">// 因为 不存在 ** 环 ** , 所以只有一条 路径, bob --&gt; 0. 所以 找到一条直接返回就行了</span></span><br><span class="line">            <span class="keyword">if</span>(!used[no] &amp;&amp; bobToNode(used,graph,map,no,curTime+ <span class="number">1</span> ))&#123; <span class="comment">// 找到路径了</span></span><br><span class="line"><span class="comment">//                map[no] = curTime;</span></span><br><span class="line">                map[node] = curTime;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这里 在 if(used[]) 的时候 ,很容易就写成 node 而不是 其 邻接点 no, 这个题是个好题,能够很好的理解图的遍历   </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 在一个图中,标记两个点的 之间的路径 path[] </span><br><span class="line">    比如 这里的 bobToNode </span><br><span class="line">    那这里的   Boolean <span class="title function_">dfs</span><span class="params">()</span> 函数的 意义: 从当前节点 能不能可达 node( 开始的 节点), 然后用 全局数组path , 进行这两个节点的 路径节点的标记!</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>









<ul>
<li><input disabled="" type="checkbox"> lc124 二叉树的最大路径和 ( 这个题 很不错的!) , 尤其是全局变量的 max 的运用<ul>
<li><input disabled="" type="checkbox"> 那这样的话, 很多题 都可以用 全局变量max 来解决, 比如  递归的一些题(  另类的动态规划里面的一些题 !</li>
<li><input disabled="" type="checkbox"> 注意一下这里的 函数的意义:</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(node)</span> : 表示的是  node 这颗树的 最大序列 值, 这里的最大 序列值是指 : 三种情况  <span class="comment">// 一定要理清 f()函数的定义</span></span><br><span class="line">    CurMax 候选:  (因为这里的序列, 有条件限制, 只能由 一条路径 连下来, 不能 有 分叉)</span><br><span class="line">        - cur 当前节点本身的值</span><br><span class="line">        - cur + leftMax</span><br><span class="line">        - cur + rightMax</span><br><span class="line">    Max全局最大值的候选:</span><br><span class="line">		  - cur 当前节点本身的值</span><br><span class="line">          - cur + leftMax</span><br><span class="line">          - cur + rightMax</span><br><span class="line">          - cur + leftMax + rightMax  <span class="comment">// 这个 不是 f(node) 的候选, 而是 全局最大值的候选!</span></span><br><span class="line">    <span class="comment">// 这里还是有点小难以理解的!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//            return Integer.MIN_VALUE; // return 这个 整形最小值， 是错的， 因为会溢出， 一定要注意这一点， 你可以  MIN_VALUE / 4  MIN_VALUE / 8 都行， 不要 传个最小值， 可能有时候 会有问题</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0 也是没有任何问题 的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftData</span> <span class="operator">=</span> recursion(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightData</span> <span class="operator">=</span> recursion(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> leftData + rightData + node.val;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         curMax ：候选人：</span></span><br><span class="line"><span class="comment">            - cur 当前节点本身的值</span></span><br><span class="line"><span class="comment">            - cur + leftMax</span></span><br><span class="line"><span class="comment">            - cur + rightMax</span></span><br><span class="line"><span class="comment">            // - cur + leftMax + rightMax  // 这个 不是 f(node) 的候选, 而是 全局最大值的候选!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; integers = Arrays.asList(node.val, node.val + leftData, node.val + rightData, node.val + leftData + rightData);</span></span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(node.val, node.val + leftData, node.val + rightData);</span><br><span class="line">        <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> integers.stream().max((a,b) -&gt; a - b).get();</span><br><span class="line">        max = Math.max(curMax,max);</span><br><span class="line">        max = Math.max(max,temp);</span><br><span class="line">        <span class="keyword">return</span>  curMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<ul>
<li><input disabled="" type="checkbox"> 二叉树的最大路径和( 朴素版  )</li>
</ul>
<blockquote>
<p>给你一颗二叉树, 每个节点, 的值 都是整数(  0 , 整数. 负数), 求 从 <strong>从根节点 到  某个 叶子节点的 路径和最大的路径</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">题不难, 但是 这个题 同  lc2466 一样, 需要考虑一个点!</span><br><span class="line">对于 叶子节点,到底该怎么处理!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 写,递归函数, 就要思考该递归函数的意义:</span></span><br><span class="line">    f() 的意义: 表示的是 以 当前 node 为头节点的树,到某个 叶子节点的最大路径和!</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里return 什么 是个 很关键的点</span></span><br><span class="line"><span class="comment">            ,应该返回一个 对结果没有 影响的值,</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">           -  return 0 显然不太行, 因为 0 &gt; 负数, 而node 的值 可为负数,会对结果造成影响</span></span><br><span class="line"><span class="comment">           </span></span><br><span class="line"><span class="comment">           - return Integer.MIN , 但是 如果对 结束 返回的结果不去判断一下的话,也会出现问题</span></span><br><span class="line"><span class="comment">           所以 ,返回这个值的话, 还需要对结果进行判断一下!</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Math.max(f(node.left, node.right)); <span class="comment">// 找出大的</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 进而 判断一下当前节点是不是叶子节点, 如果是 叶子节点, 直接返回 该节点值!</span></span><br><span class="line">    	<span class="keyword">return</span> node.val +  ( ans == Integer.MIN_VALUE ? <span class="number">0</span> : ans);</span><br><span class="line">   </span><br><span class="line">	&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>









<ul>
<li><p><input disabled="" type="checkbox"> 
路径总和系列的题!</p>
<ul>
<li><input disabled="" type="checkbox"> lc437 路径总和3 （ 这个题，真的牛逼， 一定要自己写出来！）</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox"> 
剑指offer 110所有路径! (这是一个 图的 一个题)</p>
</li>
</ul>
<blockquote>
<p>DFS : 图的 和树的</p>
<p>BFS : 图的 和 树的</p>
</blockquote>
<p>掌握树的 ,其实,图的也就差不多了!, 其实二叉树的权重, 比 图的权重要一些!</p>
<blockquote>
<p>单源最短路径有关的题目!</p>
<ol>
<li>带权</li>
<li>最短路径问题, 通常不<strong>强调</strong>, <strong>有向还是无向!</strong></li>
</ol>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"> lc743网络延迟时间!</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个 题,称得上是 特别典型的 Dijkstra 的 板子题, 直接看这个题</span><br><span class="line">    就行了, 这个最短路算法, 是必须要掌握的,没啥可说,多写, 写熟练!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Dijkstra</strong>: 需要注意的一些点!</p>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104338075.png" alt="image-20230825104338075"></p>
<ul>
<li><input disabled="" type="checkbox"> lc1976. 到达目的地的方案数</li>
</ul>
<blockquote>
<p>这个题是真的不错！说实话！下</p>
<p>目前下面这个题解，是目前感觉 最容易 写的 一个了！</p>
<p>这个题需要好好理解一下！</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/solutions/952334/dijkstrasuan-chu-zui-duan-lu-de-tong-shi-izlt/">1976. 到达目的地的方案数 - 力扣（Leetcode）</a></p>
<p>可以加个餐！</p>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104350993.png" alt="image-20230825104350993"></p>
<ul>
<li><p><input disabled="" type="checkbox"> 
lcp 56信物传送  (矩阵 化 图, 最小路板子题!)</p>
</li>
<li><p><input disabled="" type="checkbox"> 
P1086. 2023.3.16-二维矩阵可传送的最短路</p>
</li>
</ul>
<blockquote>
<p>这个题,现在感觉 还整不了, 等之后写过一些 经典的图的题之后,再来争这个题!</p>
</blockquote>
<blockquote>
<p>拓扑排序的图的算法,整一下!</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"> lc 1494并行课程II (这题的意图,太他妈明显了!)</li>
</ul>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><blockquote>
<p>最关键的一个点, 在于 给出 一个题目,</p>
<p><strong>如果是并查集 能解决的题目, 那么怎么样 能 转成 并查集, 这是比较关键的!</strong></p>
</blockquote>
<ul>
<li><p><input disabled="" type="checkbox"> 
lc200 岛屿数量 (毫无疑问,这道题是非常经典的题目!)</p>
</li>
<li><p><input disabled="" type="checkbox"> 
lc695 岛屿的最大面积  (<strong>网格 与 并查集 点 集对应关系</strong>)</p>
</li>
</ul>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h5 id="bitMap-可以表示集合"><a href="#bitMap-可以表示集合" class="headerlink" title="bitMap 可以表示集合"></a>bitMap 可以表示集合</h5><blockquote>
<p>比如 一个 int 的 state变量 可以表示 一个  容量 为 32 位的集合!</p>
<p>这在 <strong>状态压缩的dp</strong> 很常用!</p>
</blockquote>
<blockquote>
<p> 说什么，来什么，参考下灵神的总结！</p>
<p> 而且里面还有很多的  <strong>题单</strong> , 在里面!</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/CaOJ45/">从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></p>
<blockquote>
<p>每日一题: 的高质量题解精选</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md">codeforces-go&#x2F;leetcode&#x2F;SOLUTIONS.md at master · EndlessCheng&#x2F;codeforces-go · GitHub</a></p>
<p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104411719.png" alt="image-20230825104411719"></p>
<h4 id="概率题"><a href="#概率题" class="headerlink" title="概率题"></a>概率题</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/8DFJ6a/">题目分享｜一道富途的面试题 - 力扣（LeetCode）</a></p>
<ul>
<li><input disabled="" type="checkbox"> lc470用 rand7() 实现 rand10()</li>
</ul>
<h4 id="对数器的完善！"><a href="#对数器的完善！" class="headerlink" title="对数器的完善！"></a>对数器的完善！</h4><p>对数器 结果 比较还需要进行完善！</p>
<ul>
<li><input disabled="" type="checkbox"> 结果是数组型</li>
<li><input disabled="" type="checkbox"> 结果是 单纯一个 结果 数字</li>
<li><input disabled="" type="checkbox"> 结果是字符串</li>
<li><input disabled="" type="checkbox"> and so  on;</li>
</ul>
<p>对数器数组的生成不完善</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 仅正数</li>
<li><input checked="" disabled="" type="checkbox"> 仅负数</li>
<li><input checked="" disabled="" type="checkbox"> 整数</li>
<li><input disabled="" type="checkbox"> 非0 整数</li>
</ul>
<h4 id="数据量的问题"><a href="#数据量的问题" class="headerlink" title="数据量的问题"></a>数据量的问题</h4><blockquote>
<p>其实这种问题的话, 左程云讲的倒是不少的!</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/KjLOrJ/">讨论｜今天字节面试遇到的两个面试题，想跟大家探讨一下。 - 力扣（LeetCode）</a></p>
<h4 id="塔子哥每日补题"><a href="#塔子哥每日补题" class="headerlink" title="塔子哥每日补题"></a>塔子哥每日补题</h4><p><a target="_blank" rel="noopener" href="https://codefun2000.com/training/647493894f2553862fd69128">训练详情 - CodeFun2000</a></p>
<blockquote>
<p>都是公司的真实笔试题!</p>
<p>问题是: 现在 题解收费!</p>
</blockquote>
<h4 id="灵神的基础算法精讲"><a href="#灵神的基础算法精讲" class="headerlink" title="灵神的基础算法精讲"></a>灵神的基础算法精讲</h4><blockquote>
<p>可以去学习一下, 其中的一些简单的思想</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AM4y1x7r4/?spm_id_from=333.999.0.0&vd_source=179da737184de5a8f84e4f6c2ee5c350">总结：枚举选哪个 vs 选或不选【力扣双周赛 109】_哔哩哔哩_bilibili</a></p>
<blockquote>
<p>这一下子 把 折磨多的疑惑 给解开了!</p>
</blockquote>
<p><strong>如果 我采用  O(N ^ 2) 的dp 写法, 能不能通过  斜率 优化, 给它 优化成O(N) ?</strong></p>
<p><img src="/../%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E8%BF%9B%E5%BA%A6.assets/image-20230724115653903.png" alt="image-20230724115653903"></p>
<blockquote>
<p><strong>校招 VIP 中的 哪些 题单！</strong>，  他给出的那些题， 看下哪些还需要进行一个强化！</p>
</blockquote>
<h4 id="急需补写的题目"><a href="#急需补写的题目" class="headerlink" title="急需补写的题目"></a><strong>急需补写的题目</strong></h4><p><img src="/../%E7%AE%97%E6%B3%95.assets/image-20230825104448157.png" alt="image-20230825104448157"></p>
<h4 id="力扣-热题-100"><a href="#力扣-热题-100" class="headerlink" title="力扣 热题 100"></a>力扣 热题 100</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/studyplan/top-100-liked/">LeetCode 热题 100 - 学习计划 - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 算法与数据结构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/04/29/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="next" title="分布式锁锁">
                <i class="fa fa-chevron-left"></i> 分布式锁锁
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/05/24/spring%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E5%92%8C%E7%9B%91%E5%90%AC/" rel="prev" title="spring的事件">
                spring的事件 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#dp"><span class="nav-number">1.</span> <span class="nav-text">dp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">2.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">二分算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">贪心问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%A7%8D%E6%AF%94%E8%BE%83%E9%AA%9A%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">一种比较骚的排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E8%BF%9B%E5%BA%A6"><span class="nav-number">6.</span> <span class="nav-text">算法复习进度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86"><span class="nav-number">6.1.</span> <span class="nav-text">二分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BA%8C%E5%88%86%E7%9A%84%E6%9D%BF%E5%AD%90"><span class="nav-number">6.1.1.</span> <span class="nav-text">1. 二分的板子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2%E6%99%AE%E9%80%9A%E7%9A%84%E4%BA%8C%E5%88%86%E7%9A%84%E9%A2%98%E7%9B%AE-plus-%E4%B8%80%E4%BA%9B%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">6.1.2.</span> <span class="nav-text">1.2普通的二分的题目 (+  plus 一些前缀和)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88"><span class="nav-number">6.1.3.</span> <span class="nav-text">1.3 二分答案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">6.2.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dp-1"><span class="nav-number">6.3.</span> <span class="nav-text">dp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9C%8B%E4%B8%8B%E9%AB%98%E6%89%8B%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">6.4.</span> <span class="nav-text">看下高手的总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97"><span class="nav-number">6.5.</span> <span class="nav-text">股票系列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E7%B3%BB%E5%88%97"><span class="nav-number">6.6.</span> <span class="nav-text">差分系列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E5%9B%BE"><span class="nav-number">6.7.</span> <span class="nav-text">树和图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">6.8.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">6.9.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#bitMap-%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88"><span class="nav-number">6.9.1.</span> <span class="nav-text">bitMap 可以表示集合</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E7%8E%87%E9%A2%98"><span class="nav-number">6.10.</span> <span class="nav-text">概率题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0%E5%99%A8%E7%9A%84%E5%AE%8C%E5%96%84%EF%BC%81"><span class="nav-number">6.11.</span> <span class="nav-text">对数器的完善！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.12.</span> <span class="nav-text">数据量的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A1%94%E5%AD%90%E5%93%A5%E6%AF%8F%E6%97%A5%E8%A1%A5%E9%A2%98"><span class="nav-number">6.13.</span> <span class="nav-text">塔子哥每日补题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%81%B5%E7%A5%9E%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2"><span class="nav-number">6.14.</span> <span class="nav-text">灵神的基础算法精讲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A5%E9%9C%80%E8%A1%A5%E5%86%99%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="nav-number">6.15.</span> <span class="nav-text">急需补写的题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9B%E6%89%A3-%E7%83%AD%E9%A2%98-100"><span class="nav-number">6.16.</span> <span class="nav-text">力扣 热题 100</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2022 &mdash; <span itemprop="copyrightYear">2023</span>
  <!-- <span class="with-love">
    <i class="fa fa-"></i>
  </span> -->
  <span class="author" itemprop="copyrightHolder">Ego</span>

  
</div>






  <span class="post-meta-divider">|</span>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/ego/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/ego/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/ego/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/ego/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ego/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ego/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
